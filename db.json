{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/default.png","path":"img/default.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"94d8707b187843988ec16ad818be6edfe3948908","modified":1729471862749},{"_id":"source/about/index.md","hash":"bf20f274fc4fa26e18917a5de9f5967dc7fe4eca","modified":1729473067295},{"_id":"source/js/duration.js","hash":"d5f13de3e722eacea7c685763de0d32348417aec","modified":1729727280542},{"_id":"source/_posts/Codeforces Round 934 (Div. 2)/B.Equal XOR.md","hash":"e34d395ef945bc191447397347bae5df5714e92c","modified":1729478771284},{"_id":"source/_posts/埃拉托斯特尼筛法.md","hash":"461664c03f90f0fea66aa18513382b1fcff17a67","modified":1711537849026},{"_id":"source/_posts/算法设计与分析-上机实验5.md","hash":"3166c8294ea194f2a02d02b99912002143b71b72","modified":1729477573916},{"_id":"source/_posts/Codeforces Round 934 (Div. 2)/A.DestroyingBridges.md","hash":"62957c78377de59f471d0ae1f82b57951ee7663a","modified":1729478771282},{"_id":"source/_posts/Codeforces Round 936 (Div. 2)/A.Median of an Array.md","hash":"0f0f5e966a82849fc7741b190b75593a1a07dec1","modified":1729490345460},{"_id":"source/_posts/Codeforces Round 936 (Div. 2)/B.MaximumSum.md","hash":"f55fefa127e08d4829842f9f324eaa29aa5b2023","modified":1729490345442},{"_id":"source/_posts/高精度乘法.md","hash":"93d13565349732f874094918c57cf34f0a13e237","modified":1715088484112},{"_id":"source/_posts/Codeforces Round 937 (Div. 4)/A.Stair,Peak,or Neither.md","hash":"5e2b5364c4e4a9f49d49d3f6b17a213f24d5c203","modified":1729490345465},{"_id":"source/_posts/Codeforces Round 937 (Div. 4)/B.Upscaling.md","hash":"f925f61d2723b85c14adacc1e2898b894b79e1b9","modified":1729490345437},{"_id":"source/_posts/Codeforces Round 946 (Div. 3)/A.Phone Desktop.md","hash":"e09eb04c6ff2fa42deb2247d54b88c51e71e7955","modified":1729490345445},{"_id":"source/_posts/Codeforces Round 946 (Div. 3)/B.Symmetric Encoding.md","hash":"3dbee0688aebd0271a13c6978781f314a4fb6404","modified":1729490345447},{"_id":"source/_posts/Codeforces Round 937 (Div. 4)/D.Product of Binary Decimals.md","hash":"2de444f9fa3ffec1b48c4f6c6019de7de7c5a212","modified":1729490345463},{"_id":"source/_posts/Codeforces Round 946 (Div. 3)/C. Beautiful Triple Pairs.md","hash":"420edb24d02ff200be82e26fa6bb9a24bdd1c2c6","modified":1729490345449},{"_id":"source/_posts/Codeforces Round 937 (Div. 4)/C.Clock Conversion.md","hash":"ab8e1e34974c08550e0a00a52675fa6489f28fa4","modified":1729490345456},{"_id":"source/_posts/Codeforces Round 944 (Div. 4)/A. My First Sorting Problem.md","hash":"4af19745e6471ef7ee9604cb0077ac08ed906b83","modified":1729490345440},{"_id":"source/_posts/Codeforces Round 934 (Div. 2)/C.MEXGame1.md","hash":"d626653374078951c3fba332298d0dee5a79b61c","modified":1729478771279},{"_id":"source/_posts/Codeforces Round 944 (Div. 4)/B. Different String.md","hash":"3ff14d0670c8e834fc18d15eda5320bddcdbd15f","modified":1729490345434},{"_id":"source/_posts/Codeforces Round 944 (Div. 4)/C. Clock and Strings.md","hash":"b9175bea6bd191edd6a70dd2a90da619eb97e3c0","modified":1729490345454},{"_id":"source/_posts/Codeforces Round 944 (Div. 4)/D. Binary Cut.md","hash":"1f10d2f1e346139d54fb64a6db9b0623a9e04bae","modified":1729490603285},{"_id":"source/_posts/Codeforces Round 944 (Div. 4)/E. Find the Car.md","hash":"2da16ff3cec44202da4db5b611da9e655267b9f6","modified":1729490345452},{"_id":"themes/fluid/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/pages/about.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/source/css/_functions/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681839906000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1681839906000},{"_id":"themes/fluid/Changelog.md","hash":"2003dfc91a6327f1ccda91e96ec171c1e34d15ee","modified":1681839906000},{"_id":"themes/fluid/README.md","hash":"076f2214f6830397cae505a138682a5874e8aa06","modified":1681839906000},{"_id":"themes/fluid/LICENSE","hash":"77259cff2096bcf2974d2091a28302511b9103f4","modified":1681839906000},{"_id":"themes/fluid/_static_prefix.yml","hash":"db6576e07c96cfdbbf97d0f3b2a8743849aefdd1","modified":1681839906000},{"_id":"themes/fluid/_config.yml","hash":"ab74054f11ee40a6747d8bab12edc44f0d792653","modified":1729733630295},{"_id":"themes/fluid/languages/ja.yml","hash":"f8733edfb1401672953cec096b3cfa6c5571ef2b","modified":1681839906000},{"_id":"themes/fluid/README_en.md","hash":"601584c4fb7ee891071108f2ab7c74217f7f35f2","modified":1681839906000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"509b55bdcca735e225d2b8247b09f64df9b823a2","modified":1681839906000},{"_id":"themes/fluid/languages/en.yml","hash":"13ec2a10529a81714623fba69002a7df2972bc91","modified":1681839906000},{"_id":"themes/fluid/layout/about.ejs","hash":"f76a8db47d6a0d7a50b20328e87a759043fb5385","modified":1681839906000},{"_id":"themes/fluid/layout/404.ejs","hash":"383ac27283f76517955b83a22ef93a8e8359ff52","modified":1681839906000},{"_id":"themes/fluid/layout/archive.ejs","hash":"ed39c0a0facd2e746276e061a27ae38867f7b71c","modified":1681839906000},{"_id":"themes/fluid/layout/category.ejs","hash":"26c1486149bcec74db59bd60f53c8f7d7f700854","modified":1681839906000},{"_id":"themes/fluid/layout/index.ejs","hash":"13114c6b2a6b5b12b0d5c2ada464c3432f2fc3ce","modified":1681839906000},{"_id":"themes/fluid/layout/layout.ejs","hash":"a031a89d127a1021d99f7340831316ba9c5bbb0b","modified":1681839906000},{"_id":"themes/fluid/layout/categories.ejs","hash":"84deaa65d080cadf65abf8e4728217d2e29f0d08","modified":1681839906000},{"_id":"themes/fluid/layout/post.ejs","hash":"14cafe4433d551e4237981f606129d0616fdd950","modified":1681839906000},{"_id":"themes/fluid/pages/local-search.xml","hash":"92a17bc2f08c3f27bb744479fe923cc9c91888f8","modified":1681839906000},{"_id":"themes/fluid/scripts/lazyload.js","hash":"5ba01187968a80864f52222b82f702c2a6916b85","modified":1681839906000},{"_id":"themes/fluid/layout/links.ejs","hash":"09b3002f820086325976ee6733d690191c7c023d","modified":1681839906000},{"_id":"themes/fluid/scripts/merge-configs.js","hash":"457651cacc49dc4b5e02a3a4f60575ab0d32c7e0","modified":1729731751660},{"_id":"themes/fluid/scripts/local-search.js","hash":"cadf9fdbecae04058b0b6b6fc0727e8c95990a30","modified":1681839906000},{"_id":"themes/fluid/scripts/pages.js","hash":"b62aa2783da3dd81f54a826b1171447b45dba479","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/analytics.ejs","hash":"480682dcaa3df757e7158064fda9042ea16e050f","modified":1681839906000},{"_id":"themes/fluid/scripts/helpers.js","hash":"33d5af823268efe4109b8c2816e291955e7ac536","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"3e4a1b1cfe8be1e9041ee7d1aaaa7777d6970f42","modified":1681839906000},{"_id":"themes/fluid/layout/tag.ejs","hash":"7dd0cde09e80317d72985c3059e7a7fe641ca232","modified":1681839906000},{"_id":"themes/fluid/layout/tags.ejs","hash":"716769e91a69014cefffdddb137098bb2ed99297","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"1f9cb3476e94a415fbcc716a468841ef7cb0c1d4","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"8af3ece2ca83fa4be415b9340b2f16221a86fe91","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"92cbde349e8125b7e095741be391aff804f08c0b","modified":1681839906000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"818aa1166f5aeb2fa3712e11481d3c65bc211524","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"b8adf88b2659eef6a45f1d7bd876d5d2ec6aba61","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/sidebar.ejs","hash":"33e2d1309805fad9d9f7ba4e3bc2c569016f9944","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"bf89bf2c5dab04a979ccf546c4bf81eb59bbe624","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"fad3f0a21c88a972f404220c5a58255bb985464a","modified":1681839906000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"bb11c0a419de1fc4ce1ef633574ce0f9b91e1441","modified":1681839906000},{"_id":"themes/fluid/source/js/post.js","hash":"784f75febbbc5802b71cabf61a3e7e7d48c8fa75","modified":1681839906000},{"_id":"themes/fluid/source/js/local-search.js","hash":"08f98c6f945c663579cb5f1d401fb8da0ef96d2c","modified":1681839906000},{"_id":"themes/fluid/source/css/main.styl","hash":"33a5dac12a89f0b6f343f4b7f639f8cb2c29e330","modified":1681839906000},{"_id":"themes/fluid/source/js/main.js","hash":"3170c95eb938c06556cbd521e7835187f175836e","modified":1681839906000},{"_id":"themes/fluid/source/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1681839906000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1681839906000},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"4edfc9e370f168a5355bad0fc2d1380ee22e719b","modified":1681839906000},{"_id":"themes/fluid/source/img/loading.svg","hash":"229649fd6181fd3d257a6f6b00f92a23c9c9e09b","modified":1681839906000},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1681839906000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"d26bcbd01e69d813f1d5ae1bf47af802ad076f82","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"9f04506e9e18c682e7006496ad5594a80f7b93b5","modified":1681839906000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"f2c5c7840f41fbae23fe26d8b39cf112a8fa76a2","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2cfd1e0cbf0b71d74de2760fd2303bb90afedc42","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"9675b8f965e0bff99277a869c07097fb3b23974a","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/comments/waline.ejs","hash":"1ae9dd63d246334fe3067523ff61c4aa20b1f143","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"ba2ab7c2a65dac22c67cc9e9ea162202efca59a4","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/busuanzi.ejs","hash":"ad8d4de63e6057f304626f7104ba7e2fc4a0cbf3","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/hitokoto.ejs","hash":"5df4d36f6c1f334f9abc43223fa9e5211cec4245","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"326f0b94c7e9f7a2aa332b11b160f481758d7e04","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"54ce3d59005cb589c70ea1e3be6315aa7aa3711a","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"2fcc9d4e90dca9a2b70f40d223a7a1d813da5270","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/prettify.ejs","hash":"718da09140d3f4207cbea0c17404ca6b97647499","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"df532a5834c2ba74e49ec1a32f02eda8e0287825","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"2c0eda43dff1d4939b5f1ce572d2ff8b2560b578","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"20759d6fe80e49580d14aa1fcbc73a1d96dca0af","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/random_img.ejs","hash":"d2e58d1bed9c080f20323f88afb448b3c1e28648","modified":1681839906000},{"_id":"themes/fluid/source/css/_custom/custom.styl","hash":"fd9c0b4ad23864139be3bba3ff66806986ce1325","modified":1681839906000},{"_id":"themes/fluid/layout/_partial/plugins/smooth_scroll.ejs","hash":"148c5a80940d88a7d385ac627fbda926161391c4","modified":1681839906000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"271abbfef0414cb6d854a0278f8348e3f6fc70b1","modified":1681839906000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"68caf7cc73fa6211f9802b69293a2a38d7322de7","modified":1681839906000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"d8dda97285bd6d88e18ae67aa4c2bca7c9f8b4d6","modified":1681839906000},{"_id":"themes/fluid/source/lib/anchor/anchor.min.js","hash":"0996588202bd062dad6f592615cb4791e1f8be91","modified":1681839906000},{"_id":"themes/fluid/source/lib/backstretch/jquery.backstretch.min.js","hash":"ebe0f47f84d88d8eddc5edf5ac0e6cbf90e84f9a","modified":1681839906000},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1681839906000},{"_id":"themes/fluid/source/lib/katex/katex.min.css","hash":"f29c27f5b804ec30acdebb8ec0488fc4a9e1538a","modified":1681839906000},{"_id":"themes/fluid/source/lib/github-markdown/github-markdown.min.css","hash":"23ec6f05c5b69aa8ffb12c59c9bf1325ee5a26d1","modified":1681839906000},{"_id":"themes/fluid/source/lib/popper/popper.min.js","hash":"27d61a7e89d12ce0744f34fa804230eeb13ff128","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"03703ece80dac645607d4731dff3fdd923777d2a","modified":1681839906000},{"_id":"themes/fluid/source/lib/prettify/github-v2.min.css","hash":"da1b8e6d4df1f044d12f461880e677d65dbbf2d3","modified":1681839906000},{"_id":"themes/fluid/source/lib/mathjax/MathJax.js","hash":"3d924a2ceb24820e86e0426b64ecee7d44e62f95","modified":1681839906000},{"_id":"themes/fluid/source/lib/prettify/prettify.min.js","hash":"03044b62cdb1c300537c14dcf424333fcf4c9110","modified":1681839906000},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night.min.css","hash":"535256d676d247d3282e9a8ae2777c6f7df4fdc6","modified":1681839906000},{"_id":"themes/fluid/source/lib/typed/typed.min.js","hash":"38b792348023d55caabd7f888ae477ee143e6abe","modified":1681839906000},{"_id":"themes/fluid/source/lib/prettify/tomorrow-night-eighties.min.css","hash":"a5f2102fc148359a92435b170f3bfb25e1221837","modified":1681839906000},{"_id":"themes/fluid/source/lib/tocbot/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1681839906000},{"_id":"themes/fluid/source/lib/smooth-scroll/SmoothScroll.min.js","hash":"ee5dea9ea4c5edb110f30a277e5fca7993f948b5","modified":1681839906000},{"_id":"themes/fluid/source/lib/prettify/tranquil-heart.min.css","hash":"0a8b26b4cbf19225b8766d80005664d42180f6b0","modified":1681839906000},{"_id":"themes/fluid/source/lib/prettify/tomorrow.min.css","hash":"ea61879c64ca73a5ea233b1315faf7f2fdfebca9","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"c8640101f16d3c9ef71d6e753b9ed55d5c5a4b17","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"43f49545fe2581338d971ecdf848942cc519e378","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"3f3a8520ee0513f3d9a2fbf7bd75d8efcb6d3d89","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"e3b1b9646d23b7e45dd0c5b6ac952183eff3f8b7","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"8c1d33e3f38d13f56bf1d5b028b6ef7cf8a17169","modified":1681839906000},{"_id":"themes/fluid/source/lib/bootstrap/js/bootstrap.min.js","hash":"8260ff4bf54350c075bc10d18e349d158e1a4af1","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/css/all.min.css","hash":"6f4095f66e56d39ef0adefbe85a1dcfc13bd133b","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"2e97930b520222ec3c2e4188ce07cc1904beba48","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"38e6bd17442bb34e0e13a2c9bcbc5299f68be173","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"5eb58f4263f87c543388bf66dec7d1f0b7c5b32c","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"8b356dc021032d9380af47f7608a6b62a9b6f363","modified":1681839906000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"ed9268c7a4ba135437ec30adfe4724cf2719e1cc","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1681839906000},{"_id":"themes/fluid/fluid_mod_logo.jpg","hash":"205e1ca24002b0869b0b4eab4757169e47b8cb77","modified":1681839906000},{"_id":"themes/fluid/source/lib/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1681839906000},{"_id":"themes/fluid/source/lib/jquery/jquery.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"453e71a65f2958480b74fdb75a53d41068699dbf","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"3fbe9822118e91350912f51f3080ce4aa9b3ec38","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"2417fe03c7330a5160f070d6ab747a2bc4bbd41b","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"9465c5894ca2f93655fa5767b820b762aff6b518","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"5d5d1448b199c38f1b39a49b1e9b3f1381a26cad","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"d378644ff0f7549fa6f217a08dfd2566a770638e","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1681839906000},{"_id":"themes/fluid/source/lib/bootstrap/css/bootstrap.min.css","hash":"3665a5389b7a20dd3b2fe9cb0ed3d80bec1cf2a3","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"f9583bce6740a4125e14d0628ffbd946b7ddfdda","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"7b280debee5800806092e35a6bc2c6fd9c51cf63","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"2b0ebea58a0bc895400dffe8c5e434c8b12338e3","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/js/mdb.min.js","hash":"fef8d611bbc14ad31ca9ec9e2990bfde4d873bb1","modified":1681839906000},{"_id":"themes/fluid/source/lib/mdbootstrap/css/mdb.min.css","hash":"62818e7755b098a1c3b503425356570a2c7474d9","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fcac55c6f9e9993cea6e2ecc729fffc36c7009b2","modified":1681839906000},{"_id":"themes/fluid/snipaste_fluid_mod.png","hash":"c24a45b893ef3af323bdb3dcd562fe9ce4e42d49","modified":1681839906000},{"_id":"themes/fluid/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"3d24b0004b9dac32a46622cefa72cb3173b13115","modified":1681839906000},{"_id":"source/img/default.png","hash":"a08b4b226b4ddd1388e6b98463888d173f148db3","modified":1616691550002},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1729730352060},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"7746460fc2eba7439b494c46aa9b5ded81370819","modified":1729730351963},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1729730351883},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1729730351887},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1729730351893},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1729730351884},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"e62d2e25cae57e8469e3f48c9d17be1fd284a969","modified":1729730352065},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1729730351879},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1729730351964},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1729730351890},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1729730352065},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1729730351906},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1729730351906},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1729730351913},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1729730351919},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1729730352066},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1729730351914},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1729730351907},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1729730352067},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1729730352069},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1729730351919},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1729730352068},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1729730352071},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1729730352072},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1729730352068},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1729730352070},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1729730351944},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1729730351895},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1729730351892},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1729730351886},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1729730351893},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1729730351899},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1729730351896},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1729730351903},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1729730351904},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1729730351908},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1729730351913},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1729730351941},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1729730351952},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1729730351916},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1729730351933},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1729730351957},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1729730351956},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1729730351953},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1729730351932},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1729730351915},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1729730352042},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1729730351933},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1729730352044},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1729730352049},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1729730351935},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1729730351946},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1729730351940},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1729730351958},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1729730351956},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1729730351960},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1729730351927},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1729730351961},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1729730351963},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1729730351935},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1729730351928},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1729730351937},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1729730351929},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1729730351954},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1729730351954},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1729730351882},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1729730351931},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1729730351955},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1729730351949},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1729730351958},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1729730351959},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1729730351926},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1729730351929},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1729730351939},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1729730351965},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1729730352021},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1729730351934},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1729730352020},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1729730351925},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1729730351952},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1729730351951},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1729730351930},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1729730351937},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1729730351959},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1729730351938},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1729730352063},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1729730351950},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1729730351939},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1729730351953},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1729730351957},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1729730351894},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1729730351945},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1729730351897},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1729730351962},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1729730351897},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1729730351902},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1729730351898},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1729730351907},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1729730351901},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1729730351921},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1729730351885},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1729730351924},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1729730351915},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1729730351922},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1729730351898},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1729730351923},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1729730351894},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1729730351899},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1729730351904},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1729730351909},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1729730351909},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1729730351885},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1729730351911},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1729730351889},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1729730351912},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1729730351891},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1729730351910},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1729730351917},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1729730352027},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1729730351918},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1729730351921},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1729730351896},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1729730351918},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1729730351920},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1729730351912},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1729730351910},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1729730352029},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1729730352054},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1729730352023},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1729730351888},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1729730352025},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1729730352032},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1729730352031},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1729730352046},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1729730352037},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1729730352034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1729730352057},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1729730352047},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1729730352045},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1729730352038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1729730352034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1729730352048},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1729730352043},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1729730352061},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1729730352050},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1729730352035},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1729730352055},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1729730352024},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1729730352056},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1729730352036},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1729730352039},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1729730352033},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1729730352040},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1729730352026},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1729730352054},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1729730352040},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1729730352052},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1729730352041},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1729730352051},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1729730352051},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1729730352058},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1729730352059},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1729730352059},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1729730352062},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1729730352018}],"Category":[{"name":"Codeforces","_id":"cm2mlm0xp0007lgw16u0l4qpa"}],"Data":[],"Page":[{"title":"标题","layout":"about","_content":"\n<center>一只努力学习算法的菜喵</center>\n\n![](https://www.helloimg.com/i/2024/10/21/6715a69769b85.png)","source":"about/index.md","raw":"---\ntitle: 标题\nlayout: about\n---\n\n<center>一只努力学习算法的菜喵</center>\n\n![](https://www.helloimg.com/i/2024/10/21/6715a69769b85.png)","date":"2024-10-21T01:11:07.295Z","updated":"2024-10-21T01:11:07.295Z","path":"about/index.html","comments":1,"_id":"cm2mlm0xi0000lgw10q3lgsuc","content":"<center>一只努力学习算法的菜喵</center>\n\n<p><img src=\"https://www.helloimg.com/i/2024/10/21/6715a69769b85.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<center>一只努力学习算法的菜喵</center>\n\n<p><img src=\"https://www.helloimg.com/i/2024/10/21/6715a69769b85.png\"></p>\n"},{"_content":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2023/10/21 00:00:00\");\n\n    function update() {\n        var now = new Date();\n        now.setTime(now.getTime()+250);\n        days = (now - start) / 1000 / 60 / 60 / 24;\n        dnum = Math.floor(days);\n        hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n        hnum = Math.floor(hours);\n        if(String(hnum).length === 1 ){\n            hnum = \"0\" + hnum;\n        }\n        minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n        mnum = Math.floor(minutes);\n        if(String(mnum).length === 1 ){\n            mnum = \"0\" + mnum;\n        }\n        seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n        snum = Math.round(seconds);\n        if(String(snum).length === 1 ){\n            snum = \"0\" + snum;\n        }\n        document.getElementById(\"timeDate\").innerHTML = \"The Blog has running \"+dnum+\" days\";\n        document.getElementById(\"times\").innerHTML = hnum + \" h \" + mnum + \" m \" + snum + \" s\";\n    }\n\n    update();\n    setInterval(update, 1000);\n})();\n","source":"js/duration.js","raw":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2023/10/21 00:00:00\");\n\n    function update() {\n        var now = new Date();\n        now.setTime(now.getTime()+250);\n        days = (now - start) / 1000 / 60 / 60 / 24;\n        dnum = Math.floor(days);\n        hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n        hnum = Math.floor(hours);\n        if(String(hnum).length === 1 ){\n            hnum = \"0\" + hnum;\n        }\n        minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n        mnum = Math.floor(minutes);\n        if(String(mnum).length === 1 ){\n            mnum = \"0\" + mnum;\n        }\n        seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n        snum = Math.round(seconds);\n        if(String(snum).length === 1 ){\n            snum = \"0\" + snum;\n        }\n        document.getElementById(\"timeDate\").innerHTML = \"The Blog has running \"+dnum+\" days\";\n        document.getElementById(\"times\").innerHTML = hnum + \" h \" + mnum + \" m \" + snum + \" s\";\n    }\n\n    update();\n    setInterval(update, 1000);\n})();\n","date":"2024-10-23T23:48:00.542Z","updated":"2024-10-23T23:48:00.542Z","path":"js/duration.js","layout":"false","title":"","comments":1,"_id":"cm2mlm0xm0002lgw1efmc1u9u","content":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2023/10/21 00:00:00\");\n\n    function update() {\n        var now = new Date();\n        now.setTime(now.getTime()+250);\n        days = (now - start) / 1000 / 60 / 60 / 24;\n        dnum = Math.floor(days);\n        hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n        hnum = Math.floor(hours);\n        if(String(hnum).length === 1 ){\n            hnum = \"0\" + hnum;\n        }\n        minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n        mnum = Math.floor(minutes);\n        if(String(mnum).length === 1 ){\n            mnum = \"0\" + mnum;\n        }\n        seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n        snum = Math.round(seconds);\n        if(String(snum).length === 1 ){\n            snum = \"0\" + snum;\n        }\n        document.getElementById(\"timeDate\").innerHTML = \"The Blog has running \"+dnum+\" days\";\n        document.getElementById(\"times\").innerHTML = hnum + \" h \" + mnum + \" m \" + snum + \" s\";\n    }\n\n    update();\n    setInterval(update, 1000);\n})();\n","site":{"data":{}},"excerpt":"","more":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2023/10/21 00:00:00\");\n\n    function update() {\n        var now = new Date();\n        now.setTime(now.getTime()+250);\n        days = (now - start) / 1000 / 60 / 60 / 24;\n        dnum = Math.floor(days);\n        hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n        hnum = Math.floor(hours);\n        if(String(hnum).length === 1 ){\n            hnum = \"0\" + hnum;\n        }\n        minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n        mnum = Math.floor(minutes);\n        if(String(mnum).length === 1 ){\n            mnum = \"0\" + mnum;\n        }\n        seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n        snum = Math.round(seconds);\n        if(String(snum).length === 1 ){\n            snum = \"0\" + snum;\n        }\n        document.getElementById(\"timeDate\").innerHTML = \"The Blog has running \"+dnum+\" days\";\n        document.getElementById(\"times\").innerHTML = hnum + \" h \" + mnum + \" m \" + snum + \" s\";\n    }\n\n    update();\n    setInterval(update, 1000);\n})();\n"}],"Post":[{"title":"埃拉托斯特尼筛法","date":"2024-03-27T11:08:33.000Z","_content":"\n### 埃拉托斯特尼筛法\t\t\n\n埃拉托斯特尼筛法是一种由古希腊数学家埃拉托斯特尼提出的一种简单检定素数的算法。它的原理是从2开始，将每个素数的各个倍数标记成合数，最后剩下的未被标记的数就是素数。\n\n例如，要得到自然数25以内的全部素数，可以按照以下步骤进行：\n\n- 列出2以后所有数：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n- 标记第一个素数2：**2** 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n- 用红色标记2的倍数：**2** 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n- 如果最大数不大于最后一个标出的素数的平方，那么剩下的所有的数都是素数，否则回到第二步。本例中，25大于2的平方，返回第二步。\n- 剩下的序列中第一个素数是3，用蓝色标记3的倍数：**2** **3** 4 5 6 7 8 **9** 10 11 12 13 14 **15** 16 17 18 19 20 **21** 22 23 24 25\n- 得到的素数是2，3。\n- 25仍然大于3的平方，再次返回第二步。\n- 序列中第一个素数是5，用绿色标记5的倍数：**2** **3** 4 **5** 6 7 8 **9** **10** 11 12 13 **14** **15** 16 17 **18** 19 **20** **21** 22 23 **24** **25**\n- 得到的素数是2，3，5。\n- 因为25是5的平方，筛选完毕。\n- 结论：去掉红色、蓝色和绿色的数，25内的素数是2，3，5，7，11，13，17，19，23。\n\n```cpp\n#define MAX 1000002 // 定义一个常量表示最大范围\nbool is_prime[MAX + 1]; // 定义一个数组表示每个数是否是质数\n\n// 定义一个函数，初始化数组\nvoid init() {\n    for (int i = 0; i <= MAX; i++) { // 遍历所有的数\n        is_prime[i] = true; // 把它们都标记为质数\n    }\n    is_prime[0] = is_prime[1] = false; // 把0和1标记为合数\n}\n\n// 定义一个函数，执行筛选操作\nvoid sieve() {\n    int r = (int) sqrt(MAX); // 计算最大范围的平方根\n    for (int i = 2; i <= r; i++) { // 从2开始到最大范围的平方根结束\n        if (is_prime[i]) { // 如果i是质数\n            for (int j = i + i; j <= MAX; j += i) { // 遍历i的所有倍数\n                is_prime[j] = false; // 把它们标记为合数\n            }\n        }\n    }\n}\n```\n\n","source":"_posts/埃拉托斯特尼筛法.md","raw":"---\ntitle: 埃拉托斯特尼筛法\ndate: 2024-03-27 19:08:33\ntags: 算法\n---\n\n### 埃拉托斯特尼筛法\t\t\n\n埃拉托斯特尼筛法是一种由古希腊数学家埃拉托斯特尼提出的一种简单检定素数的算法。它的原理是从2开始，将每个素数的各个倍数标记成合数，最后剩下的未被标记的数就是素数。\n\n例如，要得到自然数25以内的全部素数，可以按照以下步骤进行：\n\n- 列出2以后所有数：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n- 标记第一个素数2：**2** 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n- 用红色标记2的倍数：**2** 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n- 如果最大数不大于最后一个标出的素数的平方，那么剩下的所有的数都是素数，否则回到第二步。本例中，25大于2的平方，返回第二步。\n- 剩下的序列中第一个素数是3，用蓝色标记3的倍数：**2** **3** 4 5 6 7 8 **9** 10 11 12 13 14 **15** 16 17 18 19 20 **21** 22 23 24 25\n- 得到的素数是2，3。\n- 25仍然大于3的平方，再次返回第二步。\n- 序列中第一个素数是5，用绿色标记5的倍数：**2** **3** 4 **5** 6 7 8 **9** **10** 11 12 13 **14** **15** 16 17 **18** 19 **20** **21** 22 23 **24** **25**\n- 得到的素数是2，3，5。\n- 因为25是5的平方，筛选完毕。\n- 结论：去掉红色、蓝色和绿色的数，25内的素数是2，3，5，7，11，13，17，19，23。\n\n```cpp\n#define MAX 1000002 // 定义一个常量表示最大范围\nbool is_prime[MAX + 1]; // 定义一个数组表示每个数是否是质数\n\n// 定义一个函数，初始化数组\nvoid init() {\n    for (int i = 0; i <= MAX; i++) { // 遍历所有的数\n        is_prime[i] = true; // 把它们都标记为质数\n    }\n    is_prime[0] = is_prime[1] = false; // 把0和1标记为合数\n}\n\n// 定义一个函数，执行筛选操作\nvoid sieve() {\n    int r = (int) sqrt(MAX); // 计算最大范围的平方根\n    for (int i = 2; i <= r; i++) { // 从2开始到最大范围的平方根结束\n        if (is_prime[i]) { // 如果i是质数\n            for (int j = i + i; j <= MAX; j += i) { // 遍历i的所有倍数\n                is_prime[j] = false; // 把它们标记为合数\n            }\n        }\n    }\n}\n```\n\n","slug":"埃拉托斯特尼筛法","published":1,"updated":"2024-03-27T11:10:49.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xk0001lgw1htq7fze8","content":"<h3 id=\"埃拉托斯特尼筛法\"><a href=\"#埃拉托斯特尼筛法\" class=\"headerlink\" title=\"埃拉托斯特尼筛法\"></a>埃拉托斯特尼筛法</h3><p>埃拉托斯特尼筛法是一种由古希腊数学家埃拉托斯特尼提出的一种简单检定素数的算法。它的原理是从2开始，将每个素数的各个倍数标记成合数，最后剩下的未被标记的数就是素数。</p>\n<p>例如，要得到自然数25以内的全部素数，可以按照以下步骤进行：</p>\n<ul>\n<li><p>列出2以后所有数：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</p>\n</li>\n<li><p>标记第一个素数2：<strong>2</strong> 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</p>\n</li>\n<li><p>用红色标记2的倍数：<strong>2</strong> 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</p>\n</li>\n<li><p>如果最大数不大于最后一个标出的素数的平方，那么剩下的所有的数都是素数，否则回到第二步。本例中，25大于2的平方，返回第二步。</p>\n</li>\n<li><p>剩下的序列中第一个素数是3，用蓝色标记3的倍数：<strong>2</strong> <strong>3</strong> 4 5 6 7 8 <strong>9</strong> 10 11 12 13 14 <strong>15</strong> 16 17 18 19 20 <strong>21</strong> 22 23 24 25</p>\n</li>\n<li><p>得到的素数是2，3。</p>\n</li>\n<li><p>25仍然大于3的平方，再次返回第二步。</p>\n</li>\n<li><p>序列中第一个素数是5，用绿色标记5的倍数：<strong>2</strong> <strong>3</strong> 4 <strong>5</strong> 6 7 8 <strong>9</strong> <strong>10</strong> 11 12 13 <strong>14</strong> <strong>15</strong> 16 17 <strong>18</strong> 19 <strong>20</strong> <strong>21</strong> 22 23 <strong>24</strong> <strong>25</strong></p>\n</li>\n<li><p>得到的素数是2，3，5。</p>\n</li>\n<li><p>因为25是5的平方，筛选完毕。</p>\n</li>\n<li><p>结论：去掉红色、蓝色和绿色的数，25内的素数是2，3，5，7，11，13，17，19，23。</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#define MAX 1000002 // 定义一个常量表示最大范围\nbool is_prime[MAX + 1]; // 定义一个数组表示每个数是否是质数\n\n// 定义一个函数，初始化数组\nvoid init() &#123;\n    for (int i = 0; i &lt;= MAX; i++) &#123; // 遍历所有的数\n        is_prime[i] = true; // 把它们都标记为质数\n    &#125;\n    is_prime[0] = is_prime[1] = false; // 把0和1标记为合数\n&#125;\n\n// 定义一个函数，执行筛选操作\nvoid sieve() &#123;\n    int r = (int) sqrt(MAX); // 计算最大范围的平方根\n    for (int i = 2; i &lt;= r; i++) &#123; // 从2开始到最大范围的平方根结束\n        if (is_prime[i]) &#123; // 如果i是质数\n            for (int j = i + i; j &lt;= MAX; j += i) &#123; // 遍历i的所有倍数\n                is_prime[j] = false; // 把它们标记为合数\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"埃拉托斯特尼筛法\"><a href=\"#埃拉托斯特尼筛法\" class=\"headerlink\" title=\"埃拉托斯特尼筛法\"></a>埃拉托斯特尼筛法</h3><p>埃拉托斯特尼筛法是一种由古希腊数学家埃拉托斯特尼提出的一种简单检定素数的算法。它的原理是从2开始，将每个素数的各个倍数标记成合数，最后剩下的未被标记的数就是素数。</p>\n<p>例如，要得到自然数25以内的全部素数，可以按照以下步骤进行：</p>\n<ul>\n<li><p>列出2以后所有数：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</p>\n</li>\n<li><p>标记第一个素数2：<strong>2</strong> 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</p>\n</li>\n<li><p>用红色标记2的倍数：<strong>2</strong> 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</p>\n</li>\n<li><p>如果最大数不大于最后一个标出的素数的平方，那么剩下的所有的数都是素数，否则回到第二步。本例中，25大于2的平方，返回第二步。</p>\n</li>\n<li><p>剩下的序列中第一个素数是3，用蓝色标记3的倍数：<strong>2</strong> <strong>3</strong> 4 5 6 7 8 <strong>9</strong> 10 11 12 13 14 <strong>15</strong> 16 17 18 19 20 <strong>21</strong> 22 23 24 25</p>\n</li>\n<li><p>得到的素数是2，3。</p>\n</li>\n<li><p>25仍然大于3的平方，再次返回第二步。</p>\n</li>\n<li><p>序列中第一个素数是5，用绿色标记5的倍数：<strong>2</strong> <strong>3</strong> 4 <strong>5</strong> 6 7 8 <strong>9</strong> <strong>10</strong> 11 12 13 <strong>14</strong> <strong>15</strong> 16 17 <strong>18</strong> 19 <strong>20</strong> <strong>21</strong> 22 23 <strong>24</strong> <strong>25</strong></p>\n</li>\n<li><p>得到的素数是2，3，5。</p>\n</li>\n<li><p>因为25是5的平方，筛选完毕。</p>\n</li>\n<li><p>结论：去掉红色、蓝色和绿色的数，25内的素数是2，3，5，7，11，13，17，19，23。</p>\n</li>\n</ul>\n<pre><code class=\"cpp\">#define MAX 1000002 // 定义一个常量表示最大范围\nbool is_prime[MAX + 1]; // 定义一个数组表示每个数是否是质数\n\n// 定义一个函数，初始化数组\nvoid init() &#123;\n    for (int i = 0; i &lt;= MAX; i++) &#123; // 遍历所有的数\n        is_prime[i] = true; // 把它们都标记为质数\n    &#125;\n    is_prime[0] = is_prime[1] = false; // 把0和1标记为合数\n&#125;\n\n// 定义一个函数，执行筛选操作\nvoid sieve() &#123;\n    int r = (int) sqrt(MAX); // 计算最大范围的平方根\n    for (int i = 2; i &lt;= r; i++) &#123; // 从2开始到最大范围的平方根结束\n        if (is_prime[i]) &#123; // 如果i是质数\n            for (int j = i + i; j &lt;= MAX; j += i) &#123; // 遍历i的所有倍数\n                is_prime[j] = false; // 把它们标记为合数\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"算法设计与分析-上机实验5","date":"2024-10-21T01:13:02.000Z","_content":"\nP124 4.9练习题\n3.已知有序表为{3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33}，求用二分查找法查找27时所需的比较序列和比较次数\n\n```c++\n// By SnowDream\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint compareCount = 0; // 记录比较次数\n\n// 打印当前正在比较的子序列\nvoid printSubVector(const vector<int>& a, int low, int high) {\n    cout << \"当前比较序列: \";\n    for (int i = low; i <= high; ++i) {\n        cout << a[i] << \" \";\n    }\n    cout << endl;\n}\n\nint binsearch(vector<int>& a, int low, int high, int k) { // 二分查找递归算法\n    if (low <= high) { // 当前区间存在元素时\n        int mid = (low + high) / 2; // 求查找区间的中间位置\n        compareCount++; // 增加比较次数\n        printSubVector(a, low, high); // 打印当前比较的子序列\n        \n        if (k == a[mid]) { // 找到后返回其物理下标mid\n            return mid;\n        }\n        if (k < a[mid]) { // 当a[mid] > k时，在a[low..mid-1]中递归查找\n            return binsearch(a, low, mid - 1, k);\n        } else { // 当k > a[mid]时，在a[mid+1..high]中递归查找\n            return binsearch(a, mid + 1, high, k);\n        }\n    }\n    else return -1; // 若当前查找区间没有元素时返回-1\n}\n\nint binsearch(vector<int>& a, int k) { // 二分查找递归算法\n    int n = a.size();\n    return binsearch(a, 0, n - 1, k);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int k = 27;\n    vector<int> a = {3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33};\n    \n    int i = binsearch(a, k);\n    \n    if (i >= 0)\n        printf(\"a[%d]=%d\\n\", i, k);\n    else\n        printf(\"未找到%d元素\\n\", k);\n\n    cout << \"总共比较了 \" << compareCount << \" 次\" << endl;\n    \n    return 0;\n}\n```\n4.假设有14个硬币，编号为0-13，其中编号为12的硬币是假币（假币的重量比真币重），给出采用天平称重方法找出该假币的过程\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\nint findFakeCoin(vector<int>& coins, int start, int end) {\n    if (start == end) {\n        return start; // 如果只剩下一个硬币，则它就是假币\n    }\n\n    int mid = (start + end) / 2;\n    int leftWeight = 0, rightWeight = 0;\n\n    // 假设所有硬币都是真的，如果发现假币就调整重量\n    for (int i = start; i <= end; ++i) {\n        if (i <= mid)\n            leftWeight+=coins[i];\n        else\n            rightWeight+=coins[i];\n\n    }\n\n    // 根据哪边更重决定下一步搜索的范围\n    if (leftWeight > rightWeight) {\n        return findFakeCoin(coins, start, mid);\n    } else {\n        return findFakeCoin(coins, mid + 1, end);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> coins(14, 0); // 初始化所有硬币为真\n    coins[12] = 1; // 设置第12个硬币为假\n\n    int fakeCoinIndex = findFakeCoin(coins, 0, 13);\n    cout << \"假币的编号是: \" << fakeCoinIndex << endl;\n    return 0;\n}\n```\n5.有一个递增有序序列（1,3,5,6,8,10,12），给出查找k=2的插入点的过程\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 二分查找找到k的插入点\nint findInsertionPoint(const vector<int>& nums, int k) {\n    int low = 0, high = nums.size() - 1;\n    int mid;\n\n    while (low <= high) {\n        mid = low + (high - low) / 2; // 防止溢出\n        if (nums[mid] < k) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low; // 返回插入点\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> nums = {1, 3, 5, 6, 8, 10, 12};\n    int k = 2;\n    int insertionPoint = findInsertionPoint(nums, k);\n    cout << \"值 \" << k << \" 的插入点是：\" << insertionPoint << endl;\n    return 0;\n}\n```\nP108\n例4.3 计算右侧小于当前元素的个数（Leetcode315）\n给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。\n示例\n```\n输入：nums = [5,2,6,1]\n输出：[2,1,1,0]\n```\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid mergeSort(vector<int>& nums, vector<int>& indexs, vector<int>& tempindexs,vector<int>& res, int left, int right) {\n    if (left >= right) return;\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indexs, tempindexs, res, left, mid);// 递归排序左半部分\n    mergeSort(nums, indexs, tempindexs, res, mid + 1, right);// 递归排序右半部分\n    int i = left, j = mid + 1, t = 0; // 合并两个已排序的部分\n    while (i <= mid && j <= right) {\n        if (nums[indexs[i]] > nums[indexs[j]]) {\n            for (int k = i; k <= mid; k++) {// 计算右侧元素小于左侧元素的个数\n                res[indexs[k]] += (j - mid);\n            }\n            tempindexs[t++] = indexs[j++];\n        } else {\n            tempindexs[t++] = indexs[i++];\n        }\n    }\n    while (i <= mid) {   // 将剩余元素复制到临时数组中\n        tempindexs[t++] = indexs[i++];\n    }\n    while (j <= right) {\n        tempindexs[t++] = indexs[j++];\n    }\n    for (int k = left; k <= right; k++) {// 将临时数组中的元素复制回原数组\n        indexs[k] = tempindexs[k - left];\n    }\n}\n\nvector<int> countSmaller(vector<int>& nums) {\n    vector<int> res(nums.size(), 0); // 保存结果\n    vector<int> indexs(nums.size()); // 索引数组\n    for (int i = 0; i < indexs.size(); i++) { // 初始化索引数组\n        indexs[i] = i;\n    }\n    vector<int> tempindexs(indexs.size(), 0); // 临时数组\n    mergeSort(nums, indexs, tempindexs, res, 0, nums.size() - 1);\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> nums = {5, 2, 6, 1};\n    vector<int> ans = countSmaller(nums);\n    cout << \"每个元素右侧比当前元素小的元素个数：\";\n    for (int num : ans) {\n        cout << num << \" \";\n    }\n    return 0;\n}\n```\nP111 \n例4.5 设计一个算法求给定的两个有序序列的中位数\n示例\n```\n输入：a=(11,13,15,17,19)     b=(2,4,6,8,20)\n输出 : 11\n```\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 求a[s..t]序列的前半子序列\nvoid prepart(int &s, int &t) {\n    int m = (s + t) / 2;\n    t = m;\n}\n\n// 求a[s..t]序列的后半子序列\nvoid postpart(int &s, int &t) {\n    int m = (s + t) / 2;\n    if ((t - s + 1) % 2 == 1) // 序列中有奇数个元素\n        s = m;\n    else                      // 序列中有偶数个元素\n        s = m + 1;\n}\n\n// 找到两个数组的中位数\nint midnum(const int a[], int s1, int t1, const int b[], int s2, int t2) {\n    if (s1 == t1 && s2 == t2) // 均只有一个元素时返回较小者\n        return min(a[s1], b[s2]);\n    else {\n        int m1 = (s1 + t1) / 2; // 求a的中位数\n        int m2 = (s2 + t2) / 2; // 求b的中位数\n        if (a[m1] == b[m2]) // 两中位数相等时返回该中位数\n            return a[m1];\n        if (a[m1] < b[m2]) { // 当a[m1]<b[m2]时\n            postpart(s1, t1); // a取后半部分\n            prepart(s2, t2);  // b取前半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        } else { // 当a[m1]>b[m2]时\n            prepart(s1, t1); // a取前半部分\n            postpart(s2, t2); // b取后半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        }\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int a[] = {11, 13, 15, 17, 19};\n    int b[] = {2, 4, 6, 8, 20};\n    int n = sizeof(a) / sizeof(a[0]);\n    cout << \"中位数: \" << midnum(a, 0, n - 1, b, 0, n - 1) << \"\\n\";\n    return 0;\n}\n```\n","source":"_posts/算法设计与分析-上机实验5.md","raw":"---\ntitle: 算法设计与分析-上机实验5\ndate: 2024-10-21 09:13:02\ntags: \n  - 算法 \n  - 上机作业\n---\n\nP124 4.9练习题\n3.已知有序表为{3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33}，求用二分查找法查找27时所需的比较序列和比较次数\n\n```c++\n// By SnowDream\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint compareCount = 0; // 记录比较次数\n\n// 打印当前正在比较的子序列\nvoid printSubVector(const vector<int>& a, int low, int high) {\n    cout << \"当前比较序列: \";\n    for (int i = low; i <= high; ++i) {\n        cout << a[i] << \" \";\n    }\n    cout << endl;\n}\n\nint binsearch(vector<int>& a, int low, int high, int k) { // 二分查找递归算法\n    if (low <= high) { // 当前区间存在元素时\n        int mid = (low + high) / 2; // 求查找区间的中间位置\n        compareCount++; // 增加比较次数\n        printSubVector(a, low, high); // 打印当前比较的子序列\n        \n        if (k == a[mid]) { // 找到后返回其物理下标mid\n            return mid;\n        }\n        if (k < a[mid]) { // 当a[mid] > k时，在a[low..mid-1]中递归查找\n            return binsearch(a, low, mid - 1, k);\n        } else { // 当k > a[mid]时，在a[mid+1..high]中递归查找\n            return binsearch(a, mid + 1, high, k);\n        }\n    }\n    else return -1; // 若当前查找区间没有元素时返回-1\n}\n\nint binsearch(vector<int>& a, int k) { // 二分查找递归算法\n    int n = a.size();\n    return binsearch(a, 0, n - 1, k);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int k = 27;\n    vector<int> a = {3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33};\n    \n    int i = binsearch(a, k);\n    \n    if (i >= 0)\n        printf(\"a[%d]=%d\\n\", i, k);\n    else\n        printf(\"未找到%d元素\\n\", k);\n\n    cout << \"总共比较了 \" << compareCount << \" 次\" << endl;\n    \n    return 0;\n}\n```\n4.假设有14个硬币，编号为0-13，其中编号为12的硬币是假币（假币的重量比真币重），给出采用天平称重方法找出该假币的过程\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\nint findFakeCoin(vector<int>& coins, int start, int end) {\n    if (start == end) {\n        return start; // 如果只剩下一个硬币，则它就是假币\n    }\n\n    int mid = (start + end) / 2;\n    int leftWeight = 0, rightWeight = 0;\n\n    // 假设所有硬币都是真的，如果发现假币就调整重量\n    for (int i = start; i <= end; ++i) {\n        if (i <= mid)\n            leftWeight+=coins[i];\n        else\n            rightWeight+=coins[i];\n\n    }\n\n    // 根据哪边更重决定下一步搜索的范围\n    if (leftWeight > rightWeight) {\n        return findFakeCoin(coins, start, mid);\n    } else {\n        return findFakeCoin(coins, mid + 1, end);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> coins(14, 0); // 初始化所有硬币为真\n    coins[12] = 1; // 设置第12个硬币为假\n\n    int fakeCoinIndex = findFakeCoin(coins, 0, 13);\n    cout << \"假币的编号是: \" << fakeCoinIndex << endl;\n    return 0;\n}\n```\n5.有一个递增有序序列（1,3,5,6,8,10,12），给出查找k=2的插入点的过程\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 二分查找找到k的插入点\nint findInsertionPoint(const vector<int>& nums, int k) {\n    int low = 0, high = nums.size() - 1;\n    int mid;\n\n    while (low <= high) {\n        mid = low + (high - low) / 2; // 防止溢出\n        if (nums[mid] < k) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low; // 返回插入点\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> nums = {1, 3, 5, 6, 8, 10, 12};\n    int k = 2;\n    int insertionPoint = findInsertionPoint(nums, k);\n    cout << \"值 \" << k << \" 的插入点是：\" << insertionPoint << endl;\n    return 0;\n}\n```\nP108\n例4.3 计算右侧小于当前元素的个数（Leetcode315）\n给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。\n示例\n```\n输入：nums = [5,2,6,1]\n输出：[2,1,1,0]\n```\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid mergeSort(vector<int>& nums, vector<int>& indexs, vector<int>& tempindexs,vector<int>& res, int left, int right) {\n    if (left >= right) return;\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indexs, tempindexs, res, left, mid);// 递归排序左半部分\n    mergeSort(nums, indexs, tempindexs, res, mid + 1, right);// 递归排序右半部分\n    int i = left, j = mid + 1, t = 0; // 合并两个已排序的部分\n    while (i <= mid && j <= right) {\n        if (nums[indexs[i]] > nums[indexs[j]]) {\n            for (int k = i; k <= mid; k++) {// 计算右侧元素小于左侧元素的个数\n                res[indexs[k]] += (j - mid);\n            }\n            tempindexs[t++] = indexs[j++];\n        } else {\n            tempindexs[t++] = indexs[i++];\n        }\n    }\n    while (i <= mid) {   // 将剩余元素复制到临时数组中\n        tempindexs[t++] = indexs[i++];\n    }\n    while (j <= right) {\n        tempindexs[t++] = indexs[j++];\n    }\n    for (int k = left; k <= right; k++) {// 将临时数组中的元素复制回原数组\n        indexs[k] = tempindexs[k - left];\n    }\n}\n\nvector<int> countSmaller(vector<int>& nums) {\n    vector<int> res(nums.size(), 0); // 保存结果\n    vector<int> indexs(nums.size()); // 索引数组\n    for (int i = 0; i < indexs.size(); i++) { // 初始化索引数组\n        indexs[i] = i;\n    }\n    vector<int> tempindexs(indexs.size(), 0); // 临时数组\n    mergeSort(nums, indexs, tempindexs, res, 0, nums.size() - 1);\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector<int> nums = {5, 2, 6, 1};\n    vector<int> ans = countSmaller(nums);\n    cout << \"每个元素右侧比当前元素小的元素个数：\";\n    for (int num : ans) {\n        cout << num << \" \";\n    }\n    return 0;\n}\n```\nP111 \n例4.5 设计一个算法求给定的两个有序序列的中位数\n示例\n```\n输入：a=(11,13,15,17,19)     b=(2,4,6,8,20)\n输出 : 11\n```\n```c++\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\n// 求a[s..t]序列的前半子序列\nvoid prepart(int &s, int &t) {\n    int m = (s + t) / 2;\n    t = m;\n}\n\n// 求a[s..t]序列的后半子序列\nvoid postpart(int &s, int &t) {\n    int m = (s + t) / 2;\n    if ((t - s + 1) % 2 == 1) // 序列中有奇数个元素\n        s = m;\n    else                      // 序列中有偶数个元素\n        s = m + 1;\n}\n\n// 找到两个数组的中位数\nint midnum(const int a[], int s1, int t1, const int b[], int s2, int t2) {\n    if (s1 == t1 && s2 == t2) // 均只有一个元素时返回较小者\n        return min(a[s1], b[s2]);\n    else {\n        int m1 = (s1 + t1) / 2; // 求a的中位数\n        int m2 = (s2 + t2) / 2; // 求b的中位数\n        if (a[m1] == b[m2]) // 两中位数相等时返回该中位数\n            return a[m1];\n        if (a[m1] < b[m2]) { // 当a[m1]<b[m2]时\n            postpart(s1, t1); // a取后半部分\n            prepart(s2, t2);  // b取前半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        } else { // 当a[m1]>b[m2]时\n            prepart(s1, t1); // a取前半部分\n            postpart(s2, t2); // b取后半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        }\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int a[] = {11, 13, 15, 17, 19};\n    int b[] = {2, 4, 6, 8, 20};\n    int n = sizeof(a) / sizeof(a[0]);\n    cout << \"中位数: \" << midnum(a, 0, n - 1, b, 0, n - 1) << \"\\n\";\n    return 0;\n}\n```\n","slug":"算法设计与分析-上机实验5","published":1,"updated":"2024-10-21T02:26:13.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xm0003lgw111kh9v9p","content":"<p>P124 4.9练习题<br>3.已知有序表为{3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33}，求用二分查找法查找27时所需的比较序列和比较次数</p>\n<pre><code class=\"c++\">// By SnowDream\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint compareCount = 0; // 记录比较次数\n\n// 打印当前正在比较的子序列\nvoid printSubVector(const vector&lt;int&gt;&amp; a, int low, int high) &#123;\n    cout &lt;&lt; &quot;当前比较序列: &quot;;\n    for (int i = low; i &lt;= high; ++i) &#123;\n        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint binsearch(vector&lt;int&gt;&amp; a, int low, int high, int k) &#123; // 二分查找递归算法\n    if (low &lt;= high) &#123; // 当前区间存在元素时\n        int mid = (low + high) / 2; // 求查找区间的中间位置\n        compareCount++; // 增加比较次数\n        printSubVector(a, low, high); // 打印当前比较的子序列\n        \n        if (k == a[mid]) &#123; // 找到后返回其物理下标mid\n            return mid;\n        &#125;\n        if (k &lt; a[mid]) &#123; // 当a[mid] &gt; k时，在a[low..mid-1]中递归查找\n            return binsearch(a, low, mid - 1, k);\n        &#125; else &#123; // 当k &gt; a[mid]时，在a[mid+1..high]中递归查找\n            return binsearch(a, mid + 1, high, k);\n        &#125;\n    &#125;\n    else return -1; // 若当前查找区间没有元素时返回-1\n&#125;\n\nint binsearch(vector&lt;int&gt;&amp; a, int k) &#123; // 二分查找递归算法\n    int n = a.size();\n    return binsearch(a, 0, n - 1, k);\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int k = 27;\n    vector&lt;int&gt; a = &#123;3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33&#125;;\n    \n    int i = binsearch(a, k);\n    \n    if (i &gt;= 0)\n        printf(&quot;a[%d]=%d\\n&quot;, i, k);\n    else\n        printf(&quot;未找到%d元素\\n&quot;, k);\n\n    cout &lt;&lt; &quot;总共比较了 &quot; &lt;&lt; compareCount &lt;&lt; &quot; 次&quot; &lt;&lt; endl;\n    \n    return 0;\n&#125;\n</code></pre>\n<p>4.假设有14个硬币，编号为0-13，其中编号为12的硬币是假币（假币的重量比真币重），给出采用天平称重方法找出该假币的过程</p>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint findFakeCoin(vector&lt;int&gt;&amp; coins, int start, int end) &#123;\n    if (start == end) &#123;\n        return start; // 如果只剩下一个硬币，则它就是假币\n    &#125;\n\n    int mid = (start + end) / 2;\n    int leftWeight = 0, rightWeight = 0;\n\n    // 假设所有硬币都是真的，如果发现假币就调整重量\n    for (int i = start; i &lt;= end; ++i) &#123;\n        if (i &lt;= mid)\n            leftWeight+=coins[i];\n        else\n            rightWeight+=coins[i];\n\n    &#125;\n\n    // 根据哪边更重决定下一步搜索的范围\n    if (leftWeight &gt; rightWeight) &#123;\n        return findFakeCoin(coins, start, mid);\n    &#125; else &#123;\n        return findFakeCoin(coins, mid + 1, end);\n    &#125;\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector&lt;int&gt; coins(14, 0); // 初始化所有硬币为真\n    coins[12] = 1; // 设置第12个硬币为假\n\n    int fakeCoinIndex = findFakeCoin(coins, 0, 13);\n    cout &lt;&lt; &quot;假币的编号是: &quot; &lt;&lt; fakeCoinIndex &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<p>5.有一个递增有序序列（1,3,5,6,8,10,12），给出查找k&#x3D;2的插入点的过程</p>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 二分查找找到k的插入点\nint findInsertionPoint(const vector&lt;int&gt;&amp; nums, int k) &#123;\n    int low = 0, high = nums.size() - 1;\n    int mid;\n\n    while (low &lt;= high) &#123;\n        mid = low + (high - low) / 2; // 防止溢出\n        if (nums[mid] &lt; k) &#123;\n            low = mid + 1;\n        &#125; else &#123;\n            high = mid - 1;\n        &#125;\n    &#125;\n    return low; // 返回插入点\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector&lt;int&gt; nums = &#123;1, 3, 5, 6, 8, 10, 12&#125;;\n    int k = 2;\n    int insertionPoint = findInsertionPoint(nums, k);\n    cout &lt;&lt; &quot;值 &quot; &lt;&lt; k &lt;&lt; &quot; 的插入点是：&quot; &lt;&lt; insertionPoint &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<p>P108<br>例4.3 计算右侧小于当前元素的个数（Leetcode315）<br>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br>示例</p>\n<pre><code>输入：nums = [5,2,6,1]\n输出：[2,1,1,0]\n</code></pre>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid mergeSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; indexs, vector&lt;int&gt;&amp; tempindexs,vector&lt;int&gt;&amp; res, int left, int right) &#123;\n    if (left &gt;= right) return;\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indexs, tempindexs, res, left, mid);// 递归排序左半部分\n    mergeSort(nums, indexs, tempindexs, res, mid + 1, right);// 递归排序右半部分\n    int i = left, j = mid + 1, t = 0; // 合并两个已排序的部分\n    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;\n        if (nums[indexs[i]] &gt; nums[indexs[j]]) &#123;\n            for (int k = i; k &lt;= mid; k++) &#123;// 计算右侧元素小于左侧元素的个数\n                res[indexs[k]] += (j - mid);\n            &#125;\n            tempindexs[t++] = indexs[j++];\n        &#125; else &#123;\n            tempindexs[t++] = indexs[i++];\n        &#125;\n    &#125;\n    while (i &lt;= mid) &#123;   // 将剩余元素复制到临时数组中\n        tempindexs[t++] = indexs[i++];\n    &#125;\n    while (j &lt;= right) &#123;\n        tempindexs[t++] = indexs[j++];\n    &#125;\n    for (int k = left; k &lt;= right; k++) &#123;// 将临时数组中的元素复制回原数组\n        indexs[k] = tempindexs[k - left];\n    &#125;\n&#125;\n\nvector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;\n    vector&lt;int&gt; res(nums.size(), 0); // 保存结果\n    vector&lt;int&gt; indexs(nums.size()); // 索引数组\n    for (int i = 0; i &lt; indexs.size(); i++) &#123; // 初始化索引数组\n        indexs[i] = i;\n    &#125;\n    vector&lt;int&gt; tempindexs(indexs.size(), 0); // 临时数组\n    mergeSort(nums, indexs, tempindexs, res, 0, nums.size() - 1);\n    return res;\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector&lt;int&gt; nums = &#123;5, 2, 6, 1&#125;;\n    vector&lt;int&gt; ans = countSmaller(nums);\n    cout &lt;&lt; &quot;每个元素右侧比当前元素小的元素个数：&quot;;\n    for (int num : ans) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p>P111<br>例4.5 设计一个算法求给定的两个有序序列的中位数<br>示例</p>\n<pre><code>输入：a=(11,13,15,17,19)     b=(2,4,6,8,20)\n输出 : 11\n</code></pre>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 求a[s..t]序列的前半子序列\nvoid prepart(int &amp;s, int &amp;t) &#123;\n    int m = (s + t) / 2;\n    t = m;\n&#125;\n\n// 求a[s..t]序列的后半子序列\nvoid postpart(int &amp;s, int &amp;t) &#123;\n    int m = (s + t) / 2;\n    if ((t - s + 1) % 2 == 1) // 序列中有奇数个元素\n        s = m;\n    else                      // 序列中有偶数个元素\n        s = m + 1;\n&#125;\n\n// 找到两个数组的中位数\nint midnum(const int a[], int s1, int t1, const int b[], int s2, int t2) &#123;\n    if (s1 == t1 &amp;&amp; s2 == t2) // 均只有一个元素时返回较小者\n        return min(a[s1], b[s2]);\n    else &#123;\n        int m1 = (s1 + t1) / 2; // 求a的中位数\n        int m2 = (s2 + t2) / 2; // 求b的中位数\n        if (a[m1] == b[m2]) // 两中位数相等时返回该中位数\n            return a[m1];\n        if (a[m1] &lt; b[m2]) &#123; // 当a[m1]&lt;b[m2]时\n            postpart(s1, t1); // a取后半部分\n            prepart(s2, t2);  // b取前半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        &#125; else &#123; // 当a[m1]&gt;b[m2]时\n            prepart(s1, t1); // a取前半部分\n            postpart(s2, t2); // b取后半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        &#125;\n    &#125;\n&#125;\n\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int a[] = &#123;11, 13, 15, 17, 19&#125;;\n    int b[] = &#123;2, 4, 6, 8, 20&#125;;\n    int n = sizeof(a) / sizeof(a[0]);\n    cout &lt;&lt; &quot;中位数: &quot; &lt;&lt; midnum(a, 0, n - 1, b, 0, n - 1) &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>P124 4.9练习题<br>3.已知有序表为{3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33}，求用二分查找法查找27时所需的比较序列和比较次数</p>\n<pre><code class=\"c++\">// By SnowDream\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint compareCount = 0; // 记录比较次数\n\n// 打印当前正在比较的子序列\nvoid printSubVector(const vector&lt;int&gt;&amp; a, int low, int high) &#123;\n    cout &lt;&lt; &quot;当前比较序列: &quot;;\n    for (int i = low; i &lt;= high; ++i) &#123;\n        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n&#125;\n\nint binsearch(vector&lt;int&gt;&amp; a, int low, int high, int k) &#123; // 二分查找递归算法\n    if (low &lt;= high) &#123; // 当前区间存在元素时\n        int mid = (low + high) / 2; // 求查找区间的中间位置\n        compareCount++; // 增加比较次数\n        printSubVector(a, low, high); // 打印当前比较的子序列\n        \n        if (k == a[mid]) &#123; // 找到后返回其物理下标mid\n            return mid;\n        &#125;\n        if (k &lt; a[mid]) &#123; // 当a[mid] &gt; k时，在a[low..mid-1]中递归查找\n            return binsearch(a, low, mid - 1, k);\n        &#125; else &#123; // 当k &gt; a[mid]时，在a[mid+1..high]中递归查找\n            return binsearch(a, mid + 1, high, k);\n        &#125;\n    &#125;\n    else return -1; // 若当前查找区间没有元素时返回-1\n&#125;\n\nint binsearch(vector&lt;int&gt;&amp; a, int k) &#123; // 二分查找递归算法\n    int n = a.size();\n    return binsearch(a, 0, n - 1, k);\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int k = 27;\n    vector&lt;int&gt; a = &#123;3, 5, 7, 8, 11, 15, 22, 23, 27, 29, 33&#125;;\n    \n    int i = binsearch(a, k);\n    \n    if (i &gt;= 0)\n        printf(&quot;a[%d]=%d\\n&quot;, i, k);\n    else\n        printf(&quot;未找到%d元素\\n&quot;, k);\n\n    cout &lt;&lt; &quot;总共比较了 &quot; &lt;&lt; compareCount &lt;&lt; &quot; 次&quot; &lt;&lt; endl;\n    \n    return 0;\n&#125;\n</code></pre>\n<p>4.假设有14个硬币，编号为0-13，其中编号为12的硬币是假币（假币的重量比真币重），给出采用天平称重方法找出该假币的过程</p>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint findFakeCoin(vector&lt;int&gt;&amp; coins, int start, int end) &#123;\n    if (start == end) &#123;\n        return start; // 如果只剩下一个硬币，则它就是假币\n    &#125;\n\n    int mid = (start + end) / 2;\n    int leftWeight = 0, rightWeight = 0;\n\n    // 假设所有硬币都是真的，如果发现假币就调整重量\n    for (int i = start; i &lt;= end; ++i) &#123;\n        if (i &lt;= mid)\n            leftWeight+=coins[i];\n        else\n            rightWeight+=coins[i];\n\n    &#125;\n\n    // 根据哪边更重决定下一步搜索的范围\n    if (leftWeight &gt; rightWeight) &#123;\n        return findFakeCoin(coins, start, mid);\n    &#125; else &#123;\n        return findFakeCoin(coins, mid + 1, end);\n    &#125;\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector&lt;int&gt; coins(14, 0); // 初始化所有硬币为真\n    coins[12] = 1; // 设置第12个硬币为假\n\n    int fakeCoinIndex = findFakeCoin(coins, 0, 13);\n    cout &lt;&lt; &quot;假币的编号是: &quot; &lt;&lt; fakeCoinIndex &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<p>5.有一个递增有序序列（1,3,5,6,8,10,12），给出查找k&#x3D;2的插入点的过程</p>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 二分查找找到k的插入点\nint findInsertionPoint(const vector&lt;int&gt;&amp; nums, int k) &#123;\n    int low = 0, high = nums.size() - 1;\n    int mid;\n\n    while (low &lt;= high) &#123;\n        mid = low + (high - low) / 2; // 防止溢出\n        if (nums[mid] &lt; k) &#123;\n            low = mid + 1;\n        &#125; else &#123;\n            high = mid - 1;\n        &#125;\n    &#125;\n    return low; // 返回插入点\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector&lt;int&gt; nums = &#123;1, 3, 5, 6, 8, 10, 12&#125;;\n    int k = 2;\n    int insertionPoint = findInsertionPoint(nums, k);\n    cout &lt;&lt; &quot;值 &quot; &lt;&lt; k &lt;&lt; &quot; 的插入点是：&quot; &lt;&lt; insertionPoint &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n<p>P108<br>例4.3 计算右侧小于当前元素的个数（Leetcode315）<br>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br>示例</p>\n<pre><code>输入：nums = [5,2,6,1]\n输出：[2,1,1,0]\n</code></pre>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid mergeSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; indexs, vector&lt;int&gt;&amp; tempindexs,vector&lt;int&gt;&amp; res, int left, int right) &#123;\n    if (left &gt;= right) return;\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indexs, tempindexs, res, left, mid);// 递归排序左半部分\n    mergeSort(nums, indexs, tempindexs, res, mid + 1, right);// 递归排序右半部分\n    int i = left, j = mid + 1, t = 0; // 合并两个已排序的部分\n    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;\n        if (nums[indexs[i]] &gt; nums[indexs[j]]) &#123;\n            for (int k = i; k &lt;= mid; k++) &#123;// 计算右侧元素小于左侧元素的个数\n                res[indexs[k]] += (j - mid);\n            &#125;\n            tempindexs[t++] = indexs[j++];\n        &#125; else &#123;\n            tempindexs[t++] = indexs[i++];\n        &#125;\n    &#125;\n    while (i &lt;= mid) &#123;   // 将剩余元素复制到临时数组中\n        tempindexs[t++] = indexs[i++];\n    &#125;\n    while (j &lt;= right) &#123;\n        tempindexs[t++] = indexs[j++];\n    &#125;\n    for (int k = left; k &lt;= right; k++) &#123;// 将临时数组中的元素复制回原数组\n        indexs[k] = tempindexs[k - left];\n    &#125;\n&#125;\n\nvector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;\n    vector&lt;int&gt; res(nums.size(), 0); // 保存结果\n    vector&lt;int&gt; indexs(nums.size()); // 索引数组\n    for (int i = 0; i &lt; indexs.size(); i++) &#123; // 初始化索引数组\n        indexs[i] = i;\n    &#125;\n    vector&lt;int&gt; tempindexs(indexs.size(), 0); // 临时数组\n    mergeSort(nums, indexs, tempindexs, res, 0, nums.size() - 1);\n    return res;\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector&lt;int&gt; nums = &#123;5, 2, 6, 1&#125;;\n    vector&lt;int&gt; ans = countSmaller(nums);\n    cout &lt;&lt; &quot;每个元素右侧比当前元素小的元素个数：&quot;;\n    for (int num : ans) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p>P111<br>例4.5 设计一个算法求给定的两个有序序列的中位数<br>示例</p>\n<pre><code>输入：a=(11,13,15,17,19)     b=(2,4,6,8,20)\n输出 : 11\n</code></pre>\n<pre><code class=\"c++\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 求a[s..t]序列的前半子序列\nvoid prepart(int &amp;s, int &amp;t) &#123;\n    int m = (s + t) / 2;\n    t = m;\n&#125;\n\n// 求a[s..t]序列的后半子序列\nvoid postpart(int &amp;s, int &amp;t) &#123;\n    int m = (s + t) / 2;\n    if ((t - s + 1) % 2 == 1) // 序列中有奇数个元素\n        s = m;\n    else                      // 序列中有偶数个元素\n        s = m + 1;\n&#125;\n\n// 找到两个数组的中位数\nint midnum(const int a[], int s1, int t1, const int b[], int s2, int t2) &#123;\n    if (s1 == t1 &amp;&amp; s2 == t2) // 均只有一个元素时返回较小者\n        return min(a[s1], b[s2]);\n    else &#123;\n        int m1 = (s1 + t1) / 2; // 求a的中位数\n        int m2 = (s2 + t2) / 2; // 求b的中位数\n        if (a[m1] == b[m2]) // 两中位数相等时返回该中位数\n            return a[m1];\n        if (a[m1] &lt; b[m2]) &#123; // 当a[m1]&lt;b[m2]时\n            postpart(s1, t1); // a取后半部分\n            prepart(s2, t2);  // b取前半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        &#125; else &#123; // 当a[m1]&gt;b[m2]时\n            prepart(s1, t1); // a取前半部分\n            postpart(s2, t2); // b取后半部分\n            return midnum(a, s1, t1, b, s2, t2);\n        &#125;\n    &#125;\n&#125;\n\n\nint main() &#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int a[] = &#123;11, 13, 15, 17, 19&#125;;\n    int b[] = &#123;2, 4, 6, 8, 20&#125;;\n    int n = sizeof(a) / sizeof(a[0]);\n    cout &lt;&lt; &quot;中位数: &quot; &lt;&lt; midnum(a, 0, n - 1, b, 0, n - 1) &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 934 (Div. 2)A. Destroying Bridges","date":"2024-10-21T02:32:00.000Z","_content":"\n[Codeforces Round 934 (Div. 2)](https://codeforces.com/contest/1944)\n\n[A. Destroying Bridges](https://codeforces.com/contest/1944/problem/A)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int n,k;\n    while(t--)\n    {\n        cin >> n >> k;\n        if(k>=n-1)\n            cout << \"1\" << endl;\n        else\n            cout << n << endl;\n    }\n}\n```\n","source":"_posts/Codeforces Round 934 (Div. 2)/A.DestroyingBridges.md","raw":"---\ntitle: Codeforces Round 934 (Div. 2)A. Destroying Bridges\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags:\n  - Codeforces Round 934 (Div. 2)\n---\n\n[Codeforces Round 934 (Div. 2)](https://codeforces.com/contest/1944)\n\n[A. Destroying Bridges](https://codeforces.com/contest/1944/problem/A)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int n,k;\n    while(t--)\n    {\n        cin >> n >> k;\n        if(k>=n-1)\n            cout << \"1\" << endl;\n        else\n            cout << n << endl;\n    }\n}\n```\n","slug":"Codeforces Round 934 (Div. 2)/A.DestroyingBridges","published":1,"updated":"2024-10-21T02:46:11.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xo0005lgw18rmg3oj8","content":"<p><a href=\"https://codeforces.com/contest/1944\">Codeforces Round 934 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1944/problem/A\">A. Destroying Bridges</a></p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int n,k;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k;\n        if(k&gt;=n-1)\n            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;\n        else\n            cout &lt;&lt; n &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1944\">Codeforces Round 934 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1944/problem/A\">A. Destroying Bridges</a></p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int n,k;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k;\n        if(k&gt;=n-1)\n            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;\n        else\n            cout &lt;&lt; n &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"高精度乘法","date":"2024-05-07T13:08:33.000Z","_content":"\n#### 1.高精度乘高精度的简单算法\n\n思想：倒置相乘，统一处理进位，还原。 \n\n复杂度：$o(n^2)$\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1,s2;\nint n1[N],n2[N],n3[N];//n1储存被乘数，n2储存乘数，n3储存积\n\nvoid mul()\n{\n    int l1=(int)s1.size();\n    int l2=(int)s2.size();\n    //读取字符串转换为int类型并倒置储存至数组\n    for(int i=0;i<l1;++i)\n    {\n        n1[l1-1-i]=s1[i]-'0';\n    }\n    for(int i=0;i<l2;++i)\n    {\n        n2[l2-1-i]=s2[i]-'0';\n    }\n\n    for(int i=0;i<l1;++i)\n    {\n        for(int j=0;j<l2;++j)\n        {\n            n3[i+j]+=n1[i]*n2[j];\n        }\n    }\n    //处理进位\n    int l_max=l1+l2;\n    for(int i=0;i<l_max;++i)\n    {\n        n3[i+1]+=n3[i]/10;\n        n3[i]%=10;\n    }\n    \n    if(n3[l_max])\n        l_max++;\n    while(n3[l_max-1]>=10)\n    {\n        n3[l_max]=n3[l_max-1]/10;\n        n3[l_max-1]%=10;\n        l_max++;\n    }\n    while(n3[l_max-1]==0&&l_max>1)\n        l_max--;\n\n    for(int i=l_max-1;i>=0;i--)\n    {\n        cout << n3[i];\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> s1 >> s2;\n    mul();\n    return 0;\n}\n```\n\n#### 2.高精度乘高精度FFT优化算法 \n\n思想：将两个大整数看作多项式的系数，然后利用FFT算法在$O(n log n)$的时间复杂度内计算出它们的乘积，并最终得到乘积的各位数字。\n\n复杂度：$o(nlog(n))$\n\n具体步骤：\n\n 1. 将输入的两个大整数转换为对应的多项式表示，其中每个数字位作为多项式的系数。\n 2. 对两个多项式进行补零操作，使其长度变为2的幂，方便进行FFT运算。\n 3. 利用FFT算法对两个多项式进行快速傅里叶变换，得到它们在频域上的表示。\n 4. 将两个多项式在频域上进行点乘操作，得到它们的乘积在频域上的表示。\n 5. 对乘积进行逆FFT操作，得到乘积多项式在时域上的表示。\n 6. 对乘积多项式进行进位处理，并输出最终的乘积结果。\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define L(x) (1<< (x))\ntypedef long long ll;\nconst int N=1e5+10;\n\nconst double PI = acos(-1.0);\nstring s1,s2;\ndouble ax[N],ay[N],bx[N],by[N];\nint n1[N],n2[N],n3[N];\n\n//将一个整数x的二进制表示进行位逆序排列，并返回结果。\n// 函数接受两个参数：整数x和表示位数的整数bits\nint reverseBits(int x, int bits)\n{\n    int ret = 0;//存储位逆序排列后的结果，初始化为0\n    for(int i=0;i<bits;++i)//循环bits次，对x的二进制表示进行位逆序排列\n    {\n        ret <<= 1;//将ret左移一位，为下一位的值腾出位置\n        ret |=x&1;//将x的最低位与ret进行或操作，将x的最低位值添加到ret的最低位\n        x >>=1;//将x右移一位，准备处理下一位\n    }\n    return ret;\n}\n\nvoid fft(double * a, double * b, int n, bool rev)\n{\n    int bits = 0;// 计算n的二进制表示中位数\n    while (1 << bits < n) ++bits;// 找到大于n的最小的2的幂\n    for (int i = 0; i < n; i++)\n    {\n        int j = reverseBits(i, bits);// 将i按照bits位反转后的值赋给j\n        if (i < j)// 交换a和b数组中i和j位置的值\n        {\n            swap(a[i], a[j]);\n            swap(b[i], b[j]);\n        }\n    }\n    for (int len = 2; len <= n; len <<= 1)// 迭代每个长度为len的子序列\n    {\n        int half = len >> 1;// 子序列长度的一半\n        double wmx = cos(2 * PI / len), wmy = sin(2 * PI / len);// 计算旋转因子的实部和虚部\n        if (rev) wmy = -wmy;// 如果是逆变换，则虚部取相反数\n        for (int i = 0; i < n; i += len)// 遍历每个子序列的起始位置\n        {\n            double wx = 1, wy = 0;// 初始化旋转因子\n            for (int j = 0; j < half; j++)// 遍历子序列的前半部分\n            {\n                double cx = a[i + j], cy = b[i + j];// 获取当前位置的实部和虚部\n                double dx = a[i + j + half], dy = b[i + j + half];// 获取对应的另一半的实部和虚部\n                double ex = dx * wx - dy * wy, ey = dx * wy + dy * wx;// 计算旋转后的值\n                a[i + j] = cx + ex, b[i + j] = cy + ey;// 更新前半部分的值\n                a[i + j + half] = cx - ex, b[i + j + half] = cy - ey;// 更新后半部分的值\n                double wnx = wx * wmx - wy * wmy, wny = wx * wmy + wy * wmx;// 计算下一个旋转因子\n                wx = wnx, wy = wny;// 更新旋转因子\n            }\n        }\n    }\n    if (rev)\n    {\n        for (int i = 0; i < n; i++)\n            a[i] /= n, b[i] /= n;// 对结果进行归一化\n    }\n}\n\nint solve(int l1,int l2,int ans[])\n{\n    int len = max(l1, l2), ln;\n    for(ln=0; L(ln)<len; ++ln);// 找到大于len的最小的2的幂\n    len=L(++ln);// 计算2的幂\n    for (int i = 0; i < len ; ++i)\n    {\n        if (i >= l1) ax[i] = 0, ay[i] =0;// 如果i超过l1，则ax[i]和ay[i]赋值为0\n        else ax[i] = n1[i], ay[i] = 0;// 否则将n1[i]赋值给ax[i]，ay[i]赋值为0\n    }\n    fft(ax, ay, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i < len; ++i)\n    {\n        if (i >= l2) bx[i] = 0, by[i] = 0;// 如果i超过l2，则bx[i]和by[i]赋值为0\n        else bx[i] = n2[i], by[i] = 0;// 否则将n2[i]赋值给bx[i]，by[i]赋值为0\n    }\n    fft(bx, by, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i < len; ++i)\n    {\n        double cx = ax[i] * bx[i] - ay[i] * by[i];// 计算乘积的实部\n        double cy = ax[i] * by[i] + ay[i] * bx[i];// 计算乘积的虚部\n        ax[i] = cx, ay[i] = cy;// 更新ax和ay数组的值\n    }\n    fft(ax, ay, len, true);// 进行逆快速傅里叶变换\n    for (int i = 0; i < len; ++i)\n        ans[i] = (int)(ax[i] + 0.5);// 四舍五入取整\n    return len;\n}\n\nvoid mul()\n{\n    int l;\n    int i;\n    string ans;\n    memset(n3, 0, sizeof(n3));\n    int l1 = (int)s1.size();\n    int l2 = (int)s2.size();\n    for(i = 0; i < l1; i++)\n        n1[i] = s1[l1 - i - 1]-'0';\n    for(i = 0; i < l2; i++)\n        n2[i] = s2[l2-i-1]-'0';\n    l = solve(l1,l2, n3);\n    for(i = 0; i<l || n3[i] >= 10; i++) // 进位\n    {\n        n3[i + 1] += n3[i] / 10;\n        n3[i] %= 10;\n    }\n    l = i;\n    while(n3[l] <= 0 && l>0) l--; // 检索最高位\n    for(i = l; i >= 0; i--)\n        cout << n3[i]; // 倒序输出\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> s1 >> s2;\n    mul();\n    cout << \"\\n\";\n    return 0;\n}\n```\n\n#### 3.高精度乘单精度 \n\n思想：倒置相乘，统一处理进位，再还原。 \n\n复杂度：$o(n)$\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1;\nint s2;\nint n1[N];\nvoid mul()\n{\n    string ans;\n    int l1 = (int)s1.size();\n    for(int i=0;i<l1;++i)\n    {\n        n1[l1-1-i]=s1[i]-'0';\n    }\n    int w=0;\n    for(int i=0;i<l1;++i)\n    {\n        n1[i]=n1[i]*s2+w;\n        w=n1[i]/10;\n        n1[i]=n1[i]%10;\n    }\n    while(w)\n    {\n        n1[l1++]=w%10;\n        w/=10;\n    }\n    for(int i=l1-1;i>=0;i--)\n        cout << n1[i];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> s1 >> s2;\n    mul();\n    cout << \"\\n\";\n    return 0;\n}\n```\n\n","source":"_posts/高精度乘法.md","raw":"---\ntitle: 高精度乘法\ndate: 2024-05-07 21:08:33\ntags: 算法\n---\n\n#### 1.高精度乘高精度的简单算法\n\n思想：倒置相乘，统一处理进位，还原。 \n\n复杂度：$o(n^2)$\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1,s2;\nint n1[N],n2[N],n3[N];//n1储存被乘数，n2储存乘数，n3储存积\n\nvoid mul()\n{\n    int l1=(int)s1.size();\n    int l2=(int)s2.size();\n    //读取字符串转换为int类型并倒置储存至数组\n    for(int i=0;i<l1;++i)\n    {\n        n1[l1-1-i]=s1[i]-'0';\n    }\n    for(int i=0;i<l2;++i)\n    {\n        n2[l2-1-i]=s2[i]-'0';\n    }\n\n    for(int i=0;i<l1;++i)\n    {\n        for(int j=0;j<l2;++j)\n        {\n            n3[i+j]+=n1[i]*n2[j];\n        }\n    }\n    //处理进位\n    int l_max=l1+l2;\n    for(int i=0;i<l_max;++i)\n    {\n        n3[i+1]+=n3[i]/10;\n        n3[i]%=10;\n    }\n    \n    if(n3[l_max])\n        l_max++;\n    while(n3[l_max-1]>=10)\n    {\n        n3[l_max]=n3[l_max-1]/10;\n        n3[l_max-1]%=10;\n        l_max++;\n    }\n    while(n3[l_max-1]==0&&l_max>1)\n        l_max--;\n\n    for(int i=l_max-1;i>=0;i--)\n    {\n        cout << n3[i];\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> s1 >> s2;\n    mul();\n    return 0;\n}\n```\n\n#### 2.高精度乘高精度FFT优化算法 \n\n思想：将两个大整数看作多项式的系数，然后利用FFT算法在$O(n log n)$的时间复杂度内计算出它们的乘积，并最终得到乘积的各位数字。\n\n复杂度：$o(nlog(n))$\n\n具体步骤：\n\n 1. 将输入的两个大整数转换为对应的多项式表示，其中每个数字位作为多项式的系数。\n 2. 对两个多项式进行补零操作，使其长度变为2的幂，方便进行FFT运算。\n 3. 利用FFT算法对两个多项式进行快速傅里叶变换，得到它们在频域上的表示。\n 4. 将两个多项式在频域上进行点乘操作，得到它们的乘积在频域上的表示。\n 5. 对乘积进行逆FFT操作，得到乘积多项式在时域上的表示。\n 6. 对乘积多项式进行进位处理，并输出最终的乘积结果。\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define L(x) (1<< (x))\ntypedef long long ll;\nconst int N=1e5+10;\n\nconst double PI = acos(-1.0);\nstring s1,s2;\ndouble ax[N],ay[N],bx[N],by[N];\nint n1[N],n2[N],n3[N];\n\n//将一个整数x的二进制表示进行位逆序排列，并返回结果。\n// 函数接受两个参数：整数x和表示位数的整数bits\nint reverseBits(int x, int bits)\n{\n    int ret = 0;//存储位逆序排列后的结果，初始化为0\n    for(int i=0;i<bits;++i)//循环bits次，对x的二进制表示进行位逆序排列\n    {\n        ret <<= 1;//将ret左移一位，为下一位的值腾出位置\n        ret |=x&1;//将x的最低位与ret进行或操作，将x的最低位值添加到ret的最低位\n        x >>=1;//将x右移一位，准备处理下一位\n    }\n    return ret;\n}\n\nvoid fft(double * a, double * b, int n, bool rev)\n{\n    int bits = 0;// 计算n的二进制表示中位数\n    while (1 << bits < n) ++bits;// 找到大于n的最小的2的幂\n    for (int i = 0; i < n; i++)\n    {\n        int j = reverseBits(i, bits);// 将i按照bits位反转后的值赋给j\n        if (i < j)// 交换a和b数组中i和j位置的值\n        {\n            swap(a[i], a[j]);\n            swap(b[i], b[j]);\n        }\n    }\n    for (int len = 2; len <= n; len <<= 1)// 迭代每个长度为len的子序列\n    {\n        int half = len >> 1;// 子序列长度的一半\n        double wmx = cos(2 * PI / len), wmy = sin(2 * PI / len);// 计算旋转因子的实部和虚部\n        if (rev) wmy = -wmy;// 如果是逆变换，则虚部取相反数\n        for (int i = 0; i < n; i += len)// 遍历每个子序列的起始位置\n        {\n            double wx = 1, wy = 0;// 初始化旋转因子\n            for (int j = 0; j < half; j++)// 遍历子序列的前半部分\n            {\n                double cx = a[i + j], cy = b[i + j];// 获取当前位置的实部和虚部\n                double dx = a[i + j + half], dy = b[i + j + half];// 获取对应的另一半的实部和虚部\n                double ex = dx * wx - dy * wy, ey = dx * wy + dy * wx;// 计算旋转后的值\n                a[i + j] = cx + ex, b[i + j] = cy + ey;// 更新前半部分的值\n                a[i + j + half] = cx - ex, b[i + j + half] = cy - ey;// 更新后半部分的值\n                double wnx = wx * wmx - wy * wmy, wny = wx * wmy + wy * wmx;// 计算下一个旋转因子\n                wx = wnx, wy = wny;// 更新旋转因子\n            }\n        }\n    }\n    if (rev)\n    {\n        for (int i = 0; i < n; i++)\n            a[i] /= n, b[i] /= n;// 对结果进行归一化\n    }\n}\n\nint solve(int l1,int l2,int ans[])\n{\n    int len = max(l1, l2), ln;\n    for(ln=0; L(ln)<len; ++ln);// 找到大于len的最小的2的幂\n    len=L(++ln);// 计算2的幂\n    for (int i = 0; i < len ; ++i)\n    {\n        if (i >= l1) ax[i] = 0, ay[i] =0;// 如果i超过l1，则ax[i]和ay[i]赋值为0\n        else ax[i] = n1[i], ay[i] = 0;// 否则将n1[i]赋值给ax[i]，ay[i]赋值为0\n    }\n    fft(ax, ay, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i < len; ++i)\n    {\n        if (i >= l2) bx[i] = 0, by[i] = 0;// 如果i超过l2，则bx[i]和by[i]赋值为0\n        else bx[i] = n2[i], by[i] = 0;// 否则将n2[i]赋值给bx[i]，by[i]赋值为0\n    }\n    fft(bx, by, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i < len; ++i)\n    {\n        double cx = ax[i] * bx[i] - ay[i] * by[i];// 计算乘积的实部\n        double cy = ax[i] * by[i] + ay[i] * bx[i];// 计算乘积的虚部\n        ax[i] = cx, ay[i] = cy;// 更新ax和ay数组的值\n    }\n    fft(ax, ay, len, true);// 进行逆快速傅里叶变换\n    for (int i = 0; i < len; ++i)\n        ans[i] = (int)(ax[i] + 0.5);// 四舍五入取整\n    return len;\n}\n\nvoid mul()\n{\n    int l;\n    int i;\n    string ans;\n    memset(n3, 0, sizeof(n3));\n    int l1 = (int)s1.size();\n    int l2 = (int)s2.size();\n    for(i = 0; i < l1; i++)\n        n1[i] = s1[l1 - i - 1]-'0';\n    for(i = 0; i < l2; i++)\n        n2[i] = s2[l2-i-1]-'0';\n    l = solve(l1,l2, n3);\n    for(i = 0; i<l || n3[i] >= 10; i++) // 进位\n    {\n        n3[i + 1] += n3[i] / 10;\n        n3[i] %= 10;\n    }\n    l = i;\n    while(n3[l] <= 0 && l>0) l--; // 检索最高位\n    for(i = l; i >= 0; i--)\n        cout << n3[i]; // 倒序输出\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> s1 >> s2;\n    mul();\n    cout << \"\\n\";\n    return 0;\n}\n```\n\n#### 3.高精度乘单精度 \n\n思想：倒置相乘，统一处理进位，再还原。 \n\n复杂度：$o(n)$\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1;\nint s2;\nint n1[N];\nvoid mul()\n{\n    string ans;\n    int l1 = (int)s1.size();\n    for(int i=0;i<l1;++i)\n    {\n        n1[l1-1-i]=s1[i]-'0';\n    }\n    int w=0;\n    for(int i=0;i<l1;++i)\n    {\n        n1[i]=n1[i]*s2+w;\n        w=n1[i]/10;\n        n1[i]=n1[i]%10;\n    }\n    while(w)\n    {\n        n1[l1++]=w%10;\n        w/=10;\n    }\n    for(int i=l1-1;i>=0;i--)\n        cout << n1[i];\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> s1 >> s2;\n    mul();\n    cout << \"\\n\";\n    return 0;\n}\n```\n\n","slug":"高精度乘法","published":1,"updated":"2024-05-07T13:28:04.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xp0006lgw10c5vabng","content":"<h4 id=\"1-高精度乘高精度的简单算法\"><a href=\"#1-高精度乘高精度的简单算法\" class=\"headerlink\" title=\"1.高精度乘高精度的简单算法\"></a>1.高精度乘高精度的简单算法</h4><p>思想：倒置相乘，统一处理进位，还原。 </p>\n<p>复杂度：$o(n^2)$</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1,s2;\nint n1[N],n2[N],n3[N];//n1储存被乘数，n2储存乘数，n3储存积\n\nvoid mul()\n&#123;\n    int l1=(int)s1.size();\n    int l2=(int)s2.size();\n    //读取字符串转换为int类型并倒置储存至数组\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        n1[l1-1-i]=s1[i]-&#39;0&#39;;\n    &#125;\n    for(int i=0;i&lt;l2;++i)\n    &#123;\n        n2[l2-1-i]=s2[i]-&#39;0&#39;;\n    &#125;\n\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        for(int j=0;j&lt;l2;++j)\n        &#123;\n            n3[i+j]+=n1[i]*n2[j];\n        &#125;\n    &#125;\n    //处理进位\n    int l_max=l1+l2;\n    for(int i=0;i&lt;l_max;++i)\n    &#123;\n        n3[i+1]+=n3[i]/10;\n        n3[i]%=10;\n    &#125;\n    \n    if(n3[l_max])\n        l_max++;\n    while(n3[l_max-1]&gt;=10)\n    &#123;\n        n3[l_max]=n3[l_max-1]/10;\n        n3[l_max-1]%=10;\n        l_max++;\n    &#125;\n    while(n3[l_max-1]==0&amp;&amp;l_max&gt;1)\n        l_max--;\n\n    for(int i=l_max-1;i&gt;=0;i--)\n    &#123;\n        cout &lt;&lt; n3[i];\n    &#125;\n&#125;\n\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    mul();\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"2-高精度乘高精度FFT优化算法\"><a href=\"#2-高精度乘高精度FFT优化算法\" class=\"headerlink\" title=\"2.高精度乘高精度FFT优化算法\"></a>2.高精度乘高精度FFT优化算法</h4><p>思想：将两个大整数看作多项式的系数，然后利用FFT算法在$O(n log n)$的时间复杂度内计算出它们的乘积，并最终得到乘积的各位数字。</p>\n<p>复杂度：$o(nlog(n))$</p>\n<p>具体步骤：</p>\n<ol>\n<li>将输入的两个大整数转换为对应的多项式表示，其中每个数字位作为多项式的系数。</li>\n<li>对两个多项式进行补零操作，使其长度变为2的幂，方便进行FFT运算。</li>\n<li>利用FFT算法对两个多项式进行快速傅里叶变换，得到它们在频域上的表示。</li>\n<li>将两个多项式在频域上进行点乘操作，得到它们的乘积在频域上的表示。</li>\n<li>对乘积进行逆FFT操作，得到乘积多项式在时域上的表示。</li>\n<li>对乘积多项式进行进位处理，并输出最终的乘积结果。</li>\n</ol>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define L(x) (1&lt;&lt; (x))\ntypedef long long ll;\nconst int N=1e5+10;\n\nconst double PI = acos(-1.0);\nstring s1,s2;\ndouble ax[N],ay[N],bx[N],by[N];\nint n1[N],n2[N],n3[N];\n\n//将一个整数x的二进制表示进行位逆序排列，并返回结果。\n// 函数接受两个参数：整数x和表示位数的整数bits\nint reverseBits(int x, int bits)\n&#123;\n    int ret = 0;//存储位逆序排列后的结果，初始化为0\n    for(int i=0;i&lt;bits;++i)//循环bits次，对x的二进制表示进行位逆序排列\n    &#123;\n        ret &lt;&lt;= 1;//将ret左移一位，为下一位的值腾出位置\n        ret |=x&amp;1;//将x的最低位与ret进行或操作，将x的最低位值添加到ret的最低位\n        x &gt;&gt;=1;//将x右移一位，准备处理下一位\n    &#125;\n    return ret;\n&#125;\n\nvoid fft(double * a, double * b, int n, bool rev)\n&#123;\n    int bits = 0;// 计算n的二进制表示中位数\n    while (1 &lt;&lt; bits &lt; n) ++bits;// 找到大于n的最小的2的幂\n    for (int i = 0; i &lt; n; i++)\n    &#123;\n        int j = reverseBits(i, bits);// 将i按照bits位反转后的值赋给j\n        if (i &lt; j)// 交换a和b数组中i和j位置的值\n        &#123;\n            swap(a[i], a[j]);\n            swap(b[i], b[j]);\n        &#125;\n    &#125;\n    for (int len = 2; len &lt;= n; len &lt;&lt;= 1)// 迭代每个长度为len的子序列\n    &#123;\n        int half = len &gt;&gt; 1;// 子序列长度的一半\n        double wmx = cos(2 * PI / len), wmy = sin(2 * PI / len);// 计算旋转因子的实部和虚部\n        if (rev) wmy = -wmy;// 如果是逆变换，则虚部取相反数\n        for (int i = 0; i &lt; n; i += len)// 遍历每个子序列的起始位置\n        &#123;\n            double wx = 1, wy = 0;// 初始化旋转因子\n            for (int j = 0; j &lt; half; j++)// 遍历子序列的前半部分\n            &#123;\n                double cx = a[i + j], cy = b[i + j];// 获取当前位置的实部和虚部\n                double dx = a[i + j + half], dy = b[i + j + half];// 获取对应的另一半的实部和虚部\n                double ex = dx * wx - dy * wy, ey = dx * wy + dy * wx;// 计算旋转后的值\n                a[i + j] = cx + ex, b[i + j] = cy + ey;// 更新前半部分的值\n                a[i + j + half] = cx - ex, b[i + j + half] = cy - ey;// 更新后半部分的值\n                double wnx = wx * wmx - wy * wmy, wny = wx * wmy + wy * wmx;// 计算下一个旋转因子\n                wx = wnx, wy = wny;// 更新旋转因子\n            &#125;\n        &#125;\n    &#125;\n    if (rev)\n    &#123;\n        for (int i = 0; i &lt; n; i++)\n            a[i] /= n, b[i] /= n;// 对结果进行归一化\n    &#125;\n&#125;\n\nint solve(int l1,int l2,int ans[])\n&#123;\n    int len = max(l1, l2), ln;\n    for(ln=0; L(ln)&lt;len; ++ln);// 找到大于len的最小的2的幂\n    len=L(++ln);// 计算2的幂\n    for (int i = 0; i &lt; len ; ++i)\n    &#123;\n        if (i &gt;= l1) ax[i] = 0, ay[i] =0;// 如果i超过l1，则ax[i]和ay[i]赋值为0\n        else ax[i] = n1[i], ay[i] = 0;// 否则将n1[i]赋值给ax[i]，ay[i]赋值为0\n    &#125;\n    fft(ax, ay, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i &lt; len; ++i)\n    &#123;\n        if (i &gt;= l2) bx[i] = 0, by[i] = 0;// 如果i超过l2，则bx[i]和by[i]赋值为0\n        else bx[i] = n2[i], by[i] = 0;// 否则将n2[i]赋值给bx[i]，by[i]赋值为0\n    &#125;\n    fft(bx, by, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i &lt; len; ++i)\n    &#123;\n        double cx = ax[i] * bx[i] - ay[i] * by[i];// 计算乘积的实部\n        double cy = ax[i] * by[i] + ay[i] * bx[i];// 计算乘积的虚部\n        ax[i] = cx, ay[i] = cy;// 更新ax和ay数组的值\n    &#125;\n    fft(ax, ay, len, true);// 进行逆快速傅里叶变换\n    for (int i = 0; i &lt; len; ++i)\n        ans[i] = (int)(ax[i] + 0.5);// 四舍五入取整\n    return len;\n&#125;\n\nvoid mul()\n&#123;\n    int l;\n    int i;\n    string ans;\n    memset(n3, 0, sizeof(n3));\n    int l1 = (int)s1.size();\n    int l2 = (int)s2.size();\n    for(i = 0; i &lt; l1; i++)\n        n1[i] = s1[l1 - i - 1]-&#39;0&#39;;\n    for(i = 0; i &lt; l2; i++)\n        n2[i] = s2[l2-i-1]-&#39;0&#39;;\n    l = solve(l1,l2, n3);\n    for(i = 0; i&lt;l || n3[i] &gt;= 10; i++) // 进位\n    &#123;\n        n3[i + 1] += n3[i] / 10;\n        n3[i] %= 10;\n    &#125;\n    l = i;\n    while(n3[l] &lt;= 0 &amp;&amp; l&gt;0) l--; // 检索最高位\n    for(i = l; i &gt;= 0; i--)\n        cout &lt;&lt; n3[i]; // 倒序输出\n&#125;\n\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    mul();\n    cout &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"3-高精度乘单精度\"><a href=\"#3-高精度乘单精度\" class=\"headerlink\" title=\"3.高精度乘单精度\"></a>3.高精度乘单精度</h4><p>思想：倒置相乘，统一处理进位，再还原。 </p>\n<p>复杂度：$o(n)$</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1;\nint s2;\nint n1[N];\nvoid mul()\n&#123;\n    string ans;\n    int l1 = (int)s1.size();\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        n1[l1-1-i]=s1[i]-&#39;0&#39;;\n    &#125;\n    int w=0;\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        n1[i]=n1[i]*s2+w;\n        w=n1[i]/10;\n        n1[i]=n1[i]%10;\n    &#125;\n    while(w)\n    &#123;\n        n1[l1++]=w%10;\n        w/=10;\n    &#125;\n    for(int i=l1-1;i&gt;=0;i--)\n        cout &lt;&lt; n1[i];\n&#125;\n\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    mul();\n    cout &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-高精度乘高精度的简单算法\"><a href=\"#1-高精度乘高精度的简单算法\" class=\"headerlink\" title=\"1.高精度乘高精度的简单算法\"></a>1.高精度乘高精度的简单算法</h4><p>思想：倒置相乘，统一处理进位，还原。 </p>\n<p>复杂度：$o(n^2)$</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1,s2;\nint n1[N],n2[N],n3[N];//n1储存被乘数，n2储存乘数，n3储存积\n\nvoid mul()\n&#123;\n    int l1=(int)s1.size();\n    int l2=(int)s2.size();\n    //读取字符串转换为int类型并倒置储存至数组\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        n1[l1-1-i]=s1[i]-&#39;0&#39;;\n    &#125;\n    for(int i=0;i&lt;l2;++i)\n    &#123;\n        n2[l2-1-i]=s2[i]-&#39;0&#39;;\n    &#125;\n\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        for(int j=0;j&lt;l2;++j)\n        &#123;\n            n3[i+j]+=n1[i]*n2[j];\n        &#125;\n    &#125;\n    //处理进位\n    int l_max=l1+l2;\n    for(int i=0;i&lt;l_max;++i)\n    &#123;\n        n3[i+1]+=n3[i]/10;\n        n3[i]%=10;\n    &#125;\n    \n    if(n3[l_max])\n        l_max++;\n    while(n3[l_max-1]&gt;=10)\n    &#123;\n        n3[l_max]=n3[l_max-1]/10;\n        n3[l_max-1]%=10;\n        l_max++;\n    &#125;\n    while(n3[l_max-1]==0&amp;&amp;l_max&gt;1)\n        l_max--;\n\n    for(int i=l_max-1;i&gt;=0;i--)\n    &#123;\n        cout &lt;&lt; n3[i];\n    &#125;\n&#125;\n\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    mul();\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"2-高精度乘高精度FFT优化算法\"><a href=\"#2-高精度乘高精度FFT优化算法\" class=\"headerlink\" title=\"2.高精度乘高精度FFT优化算法\"></a>2.高精度乘高精度FFT优化算法</h4><p>思想：将两个大整数看作多项式的系数，然后利用FFT算法在$O(n log n)$的时间复杂度内计算出它们的乘积，并最终得到乘积的各位数字。</p>\n<p>复杂度：$o(nlog(n))$</p>\n<p>具体步骤：</p>\n<ol>\n<li>将输入的两个大整数转换为对应的多项式表示，其中每个数字位作为多项式的系数。</li>\n<li>对两个多项式进行补零操作，使其长度变为2的幂，方便进行FFT运算。</li>\n<li>利用FFT算法对两个多项式进行快速傅里叶变换，得到它们在频域上的表示。</li>\n<li>将两个多项式在频域上进行点乘操作，得到它们的乘积在频域上的表示。</li>\n<li>对乘积进行逆FFT操作，得到乘积多项式在时域上的表示。</li>\n<li>对乘积多项式进行进位处理，并输出最终的乘积结果。</li>\n</ol>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define L(x) (1&lt;&lt; (x))\ntypedef long long ll;\nconst int N=1e5+10;\n\nconst double PI = acos(-1.0);\nstring s1,s2;\ndouble ax[N],ay[N],bx[N],by[N];\nint n1[N],n2[N],n3[N];\n\n//将一个整数x的二进制表示进行位逆序排列，并返回结果。\n// 函数接受两个参数：整数x和表示位数的整数bits\nint reverseBits(int x, int bits)\n&#123;\n    int ret = 0;//存储位逆序排列后的结果，初始化为0\n    for(int i=0;i&lt;bits;++i)//循环bits次，对x的二进制表示进行位逆序排列\n    &#123;\n        ret &lt;&lt;= 1;//将ret左移一位，为下一位的值腾出位置\n        ret |=x&amp;1;//将x的最低位与ret进行或操作，将x的最低位值添加到ret的最低位\n        x &gt;&gt;=1;//将x右移一位，准备处理下一位\n    &#125;\n    return ret;\n&#125;\n\nvoid fft(double * a, double * b, int n, bool rev)\n&#123;\n    int bits = 0;// 计算n的二进制表示中位数\n    while (1 &lt;&lt; bits &lt; n) ++bits;// 找到大于n的最小的2的幂\n    for (int i = 0; i &lt; n; i++)\n    &#123;\n        int j = reverseBits(i, bits);// 将i按照bits位反转后的值赋给j\n        if (i &lt; j)// 交换a和b数组中i和j位置的值\n        &#123;\n            swap(a[i], a[j]);\n            swap(b[i], b[j]);\n        &#125;\n    &#125;\n    for (int len = 2; len &lt;= n; len &lt;&lt;= 1)// 迭代每个长度为len的子序列\n    &#123;\n        int half = len &gt;&gt; 1;// 子序列长度的一半\n        double wmx = cos(2 * PI / len), wmy = sin(2 * PI / len);// 计算旋转因子的实部和虚部\n        if (rev) wmy = -wmy;// 如果是逆变换，则虚部取相反数\n        for (int i = 0; i &lt; n; i += len)// 遍历每个子序列的起始位置\n        &#123;\n            double wx = 1, wy = 0;// 初始化旋转因子\n            for (int j = 0; j &lt; half; j++)// 遍历子序列的前半部分\n            &#123;\n                double cx = a[i + j], cy = b[i + j];// 获取当前位置的实部和虚部\n                double dx = a[i + j + half], dy = b[i + j + half];// 获取对应的另一半的实部和虚部\n                double ex = dx * wx - dy * wy, ey = dx * wy + dy * wx;// 计算旋转后的值\n                a[i + j] = cx + ex, b[i + j] = cy + ey;// 更新前半部分的值\n                a[i + j + half] = cx - ex, b[i + j + half] = cy - ey;// 更新后半部分的值\n                double wnx = wx * wmx - wy * wmy, wny = wx * wmy + wy * wmx;// 计算下一个旋转因子\n                wx = wnx, wy = wny;// 更新旋转因子\n            &#125;\n        &#125;\n    &#125;\n    if (rev)\n    &#123;\n        for (int i = 0; i &lt; n; i++)\n            a[i] /= n, b[i] /= n;// 对结果进行归一化\n    &#125;\n&#125;\n\nint solve(int l1,int l2,int ans[])\n&#123;\n    int len = max(l1, l2), ln;\n    for(ln=0; L(ln)&lt;len; ++ln);// 找到大于len的最小的2的幂\n    len=L(++ln);// 计算2的幂\n    for (int i = 0; i &lt; len ; ++i)\n    &#123;\n        if (i &gt;= l1) ax[i] = 0, ay[i] =0;// 如果i超过l1，则ax[i]和ay[i]赋值为0\n        else ax[i] = n1[i], ay[i] = 0;// 否则将n1[i]赋值给ax[i]，ay[i]赋值为0\n    &#125;\n    fft(ax, ay, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i &lt; len; ++i)\n    &#123;\n        if (i &gt;= l2) bx[i] = 0, by[i] = 0;// 如果i超过l2，则bx[i]和by[i]赋值为0\n        else bx[i] = n2[i], by[i] = 0;// 否则将n2[i]赋值给bx[i]，by[i]赋值为0\n    &#125;\n    fft(bx, by, len, false);// 进行快速傅里叶变换\n    for (int i = 0; i &lt; len; ++i)\n    &#123;\n        double cx = ax[i] * bx[i] - ay[i] * by[i];// 计算乘积的实部\n        double cy = ax[i] * by[i] + ay[i] * bx[i];// 计算乘积的虚部\n        ax[i] = cx, ay[i] = cy;// 更新ax和ay数组的值\n    &#125;\n    fft(ax, ay, len, true);// 进行逆快速傅里叶变换\n    for (int i = 0; i &lt; len; ++i)\n        ans[i] = (int)(ax[i] + 0.5);// 四舍五入取整\n    return len;\n&#125;\n\nvoid mul()\n&#123;\n    int l;\n    int i;\n    string ans;\n    memset(n3, 0, sizeof(n3));\n    int l1 = (int)s1.size();\n    int l2 = (int)s2.size();\n    for(i = 0; i &lt; l1; i++)\n        n1[i] = s1[l1 - i - 1]-&#39;0&#39;;\n    for(i = 0; i &lt; l2; i++)\n        n2[i] = s2[l2-i-1]-&#39;0&#39;;\n    l = solve(l1,l2, n3);\n    for(i = 0; i&lt;l || n3[i] &gt;= 10; i++) // 进位\n    &#123;\n        n3[i + 1] += n3[i] / 10;\n        n3[i] %= 10;\n    &#125;\n    l = i;\n    while(n3[l] &lt;= 0 &amp;&amp; l&gt;0) l--; // 检索最高位\n    for(i = l; i &gt;= 0; i--)\n        cout &lt;&lt; n3[i]; // 倒序输出\n&#125;\n\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    mul();\n    cout &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"3-高精度乘单精度\"><a href=\"#3-高精度乘单精度\" class=\"headerlink\" title=\"3.高精度乘单精度\"></a>3.高精度乘单精度</h4><p>思想：倒置相乘，统一处理进位，再还原。 </p>\n<p>复杂度：$o(n)$</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s1;\nint s2;\nint n1[N];\nvoid mul()\n&#123;\n    string ans;\n    int l1 = (int)s1.size();\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        n1[l1-1-i]=s1[i]-&#39;0&#39;;\n    &#125;\n    int w=0;\n    for(int i=0;i&lt;l1;++i)\n    &#123;\n        n1[i]=n1[i]*s2+w;\n        w=n1[i]/10;\n        n1[i]=n1[i]%10;\n    &#125;\n    while(w)\n    &#123;\n        n1[l1++]=w%10;\n        w/=10;\n    &#125;\n    for(int i=l1-1;i&gt;=0;i--)\n        cout &lt;&lt; n1[i];\n&#125;\n\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    mul();\n    cout &lt;&lt; &quot;\\n&quot;;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 936 (Div. 2) A. Median of an Array","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 936 (Div. 2)](https://codeforces.com/contest/1946)\n\n[A. Median of an Array](https://codeforces.com/contest/1946/problem/A)\n\n中位数被定义为排序数组中索引 $\\lceil \\frac{n}{2} \\rceil$ 处的数字，因此我们可以对数组进行排序并加以处理。\n\n因此，我们先对数组进行排序，找出数组中的中位数，即数字 $a_{\\lceil \\frac{n}{2} \\rceil}$ ，让它等于 $x$ 。为了使中位数增加，即至少变为 $x + 1$ ，数组中必须至少有 $n - \\lceil \\frac{n}{2} \\rceil + 1$ 个数字大于或等于 $x + 1$ 。\n\n现在，让我们找出 $a_t$ 等于 $x$ 的最大索引 $t$ 。然后我们知道，目前有 $n - t$ 个数字大于或等于 $x + 1$ （所有这样的 $a_i$ 即 $i > t$ ），这意味着至少需要进行 $(n - \\lceil \\frac{n}{2} \\rceil + 1) - (n - t) = t - \\lceil \\frac{n}{2} \\rceil + 1$ 次运算。我认为这个估计值是可以实现的，只需对从 $\\lceil \\frac{n}{2} \\rceil$ 到 $t$ 的每个索引进行一次运算即可，因为这些索引下的所有数字都等于 $x$ ，所以在进行运算后，它们将等于 $x + 1$ 。最后，大于或等于 $x + 1$ 的数将等于 $(n - t) + (t - \\lceil \\frac{n}{2} \\rceil + 1) = n - \\lceil \\frac{n}{2} \\rceil + 1$ ，这正是我们所需要的。\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e6+10;\nll a[N];\nint n;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        int ans=0;\n        for(int i=1;i<=n;++i)\n        {\n            cin >> a[i];\n        }\n        sort(a+1,a+n+1);\n        int p = (n+1)/2;\n        for(int i=p;i<=n;++i)\n            if(a[i]==a[p])\n                ans++;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 936 (Div. 2)/A.Median of an Array.md","raw":"---\ntitle: Codeforces Round 936 (Div. 2) A. Median of an Array\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 936 (Div. 2)\n---\n[Codeforces Round 936 (Div. 2)](https://codeforces.com/contest/1946)\n\n[A. Median of an Array](https://codeforces.com/contest/1946/problem/A)\n\n中位数被定义为排序数组中索引 $\\lceil \\frac{n}{2} \\rceil$ 处的数字，因此我们可以对数组进行排序并加以处理。\n\n因此，我们先对数组进行排序，找出数组中的中位数，即数字 $a_{\\lceil \\frac{n}{2} \\rceil}$ ，让它等于 $x$ 。为了使中位数增加，即至少变为 $x + 1$ ，数组中必须至少有 $n - \\lceil \\frac{n}{2} \\rceil + 1$ 个数字大于或等于 $x + 1$ 。\n\n现在，让我们找出 $a_t$ 等于 $x$ 的最大索引 $t$ 。然后我们知道，目前有 $n - t$ 个数字大于或等于 $x + 1$ （所有这样的 $a_i$ 即 $i > t$ ），这意味着至少需要进行 $(n - \\lceil \\frac{n}{2} \\rceil + 1) - (n - t) = t - \\lceil \\frac{n}{2} \\rceil + 1$ 次运算。我认为这个估计值是可以实现的，只需对从 $\\lceil \\frac{n}{2} \\rceil$ 到 $t$ 的每个索引进行一次运算即可，因为这些索引下的所有数字都等于 $x$ ，所以在进行运算后，它们将等于 $x + 1$ 。最后，大于或等于 $x + 1$ 的数将等于 $(n - t) + (t - \\lceil \\frac{n}{2} \\rceil + 1) = n - \\lceil \\frac{n}{2} \\rceil + 1$ ，这正是我们所需要的。\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e6+10;\nll a[N];\nint n;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        int ans=0;\n        for(int i=1;i<=n;++i)\n        {\n            cin >> a[i];\n        }\n        sort(a+1,a+n+1);\n        int p = (n+1)/2;\n        for(int i=p;i<=n;++i)\n            if(a[i]==a[p])\n                ans++;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 936 (Div. 2)/A.Median of an Array","published":1,"updated":"2024-10-21T05:59:05.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xq0008lgw1gnqf2esd","content":"<p><a href=\"https://codeforces.com/contest/1946\">Codeforces Round 936 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1946/problem/A\">A. Median of an Array</a></p>\n<p>中位数被定义为排序数组中索引 $\\lceil \\frac{n}{2} \\rceil$ 处的数字，因此我们可以对数组进行排序并加以处理。</p>\n<p>因此，我们先对数组进行排序，找出数组中的中位数，即数字 $a_{\\lceil \\frac{n}{2} \\rceil}$ ，让它等于 $x$ 。为了使中位数增加，即至少变为 $x + 1$ ，数组中必须至少有 $n - \\lceil \\frac{n}{2} \\rceil + 1$ 个数字大于或等于 $x + 1$ 。</p>\n<p>现在，让我们找出 $a_t$ 等于 $x$ 的最大索引 $t$ 。然后我们知道，目前有 $n - t$ 个数字大于或等于 $x + 1$ （所有这样的 $a_i$ 即 $i &gt; t$ ），这意味着至少需要进行 $(n - \\lceil \\frac{n}{2} \\rceil + 1) - (n - t) &#x3D; t - \\lceil \\frac{n}{2} \\rceil + 1$ 次运算。我认为这个估计值是可以实现的，只需对从 $\\lceil \\frac{n}{2} \\rceil$ 到 $t$ 的每个索引进行一次运算即可，因为这些索引下的所有数字都等于 $x$ ，所以在进行运算后，它们将等于 $x + 1$ 。最后，大于或等于 $x + 1$ 的数将等于 $(n - t) + (t - \\lceil \\frac{n}{2} \\rceil + 1) &#x3D; n - \\lceil \\frac{n}{2} \\rceil + 1$ ，这正是我们所需要的。</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=2e6+10;\nll a[N];\nint n;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n;\n        int ans=0;\n        for(int i=1;i&lt;=n;++i)\n        &#123;\n            cin &gt;&gt; a[i];\n        &#125;\n        sort(a+1,a+n+1);\n        int p = (n+1)/2;\n        for(int i=p;i&lt;=n;++i)\n            if(a[i]==a[p])\n                ans++;\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1946\">Codeforces Round 936 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1946/problem/A\">A. Median of an Array</a></p>\n<p>中位数被定义为排序数组中索引 $\\lceil \\frac{n}{2} \\rceil$ 处的数字，因此我们可以对数组进行排序并加以处理。</p>\n<p>因此，我们先对数组进行排序，找出数组中的中位数，即数字 $a_{\\lceil \\frac{n}{2} \\rceil}$ ，让它等于 $x$ 。为了使中位数增加，即至少变为 $x + 1$ ，数组中必须至少有 $n - \\lceil \\frac{n}{2} \\rceil + 1$ 个数字大于或等于 $x + 1$ 。</p>\n<p>现在，让我们找出 $a_t$ 等于 $x$ 的最大索引 $t$ 。然后我们知道，目前有 $n - t$ 个数字大于或等于 $x + 1$ （所有这样的 $a_i$ 即 $i &gt; t$ ），这意味着至少需要进行 $(n - \\lceil \\frac{n}{2} \\rceil + 1) - (n - t) &#x3D; t - \\lceil \\frac{n}{2} \\rceil + 1$ 次运算。我认为这个估计值是可以实现的，只需对从 $\\lceil \\frac{n}{2} \\rceil$ 到 $t$ 的每个索引进行一次运算即可，因为这些索引下的所有数字都等于 $x$ ，所以在进行运算后，它们将等于 $x + 1$ 。最后，大于或等于 $x + 1$ 的数将等于 $(n - t) + (t - \\lceil \\frac{n}{2} \\rceil + 1) &#x3D; n - \\lceil \\frac{n}{2} \\rceil + 1$ ，这正是我们所需要的。</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=2e6+10;\nll a[N];\nint n;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n;\n        int ans=0;\n        for(int i=1;i&lt;=n;++i)\n        &#123;\n            cin &gt;&gt; a[i];\n        &#125;\n        sort(a+1,a+n+1);\n        int p = (n+1)/2;\n        for(int i=p;i&lt;=n;++i)\n            if(a[i]==a[p])\n                ans++;\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 936 (Div. 2) B. Maximum Sum","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 936 (Div. 2)](https://codeforces.com/contest/1946)\n\n[B. Maximum Sum](https://codeforces.com/contest/1946/problem/B)\n\n先求最大连续子列，后面最大连续子列多次加到原数组的和中，$max+max*2+max*3+...+sum$,类似这样\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int INF=1e6+5;\nconst int Mod=1e9+7;\nint n,a[INF],k;\nvoid solve() \n{\n\tcin>>n>>k;\n    int sum3=0;\n\tfor (int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n        sum3+=a[i];\n        sum3%=Mod;\n    }\n\tint Max=0,sum=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tsum=max(0ll,sum);\n\t\tsum+=a[i];\n\t\tMax=max(Max,sum);\n\t}\n\tfor (int i=1;i<=k;i++) {\n\t\tsum3+=Max;\n\t\tMax*=2;\n        Max%=Mod;\n\t\tsum3%=Mod;\n\t}\n\tcout<<(sum3%Mod+Mod)%Mod<<\"\\n\";\n\t// sum3 + Max + Max*2 + Max*3 \n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tint t=0;\n    cin>>t;\n\twhile (t--)\n    {\n        solve();\n    }\n\treturn 0;\n}\n```\n\n","source":"_posts/Codeforces Round 936 (Div. 2)/B.MaximumSum.md","raw":"---\ntitle: Codeforces Round 936 (Div. 2) B. Maximum Sum\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 936 (Div. 2)\n---\n[Codeforces Round 936 (Div. 2)](https://codeforces.com/contest/1946)\n\n[B. Maximum Sum](https://codeforces.com/contest/1946/problem/B)\n\n先求最大连续子列，后面最大连续子列多次加到原数组的和中，$max+max*2+max*3+...+sum$,类似这样\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int INF=1e6+5;\nconst int Mod=1e9+7;\nint n,a[INF],k;\nvoid solve() \n{\n\tcin>>n>>k;\n    int sum3=0;\n\tfor (int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n        sum3+=a[i];\n        sum3%=Mod;\n    }\n\tint Max=0,sum=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tsum=max(0ll,sum);\n\t\tsum+=a[i];\n\t\tMax=max(Max,sum);\n\t}\n\tfor (int i=1;i<=k;i++) {\n\t\tsum3+=Max;\n\t\tMax*=2;\n        Max%=Mod;\n\t\tsum3%=Mod;\n\t}\n\tcout<<(sum3%Mod+Mod)%Mod<<\"\\n\";\n\t// sum3 + Max + Max*2 + Max*3 \n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tint t=0;\n    cin>>t;\n\twhile (t--)\n    {\n        solve();\n    }\n\treturn 0;\n}\n```\n\n","slug":"Codeforces Round 936 (Div. 2)/B.MaximumSum","published":1,"updated":"2024-10-21T05:59:05.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xr000blgw17ndl7hx8","content":"<p><a href=\"https://codeforces.com/contest/1946\">Codeforces Round 936 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1946/problem/B\">B. Maximum Sum</a></p>\n<p>先求最大连续子列，后面最大连续子列多次加到原数组的和中，$max+max<em>2+max</em>3+…+sum$,类似这样</p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\n#define int long long \nusing namespace std;\nconst int INF=1e6+5;\nconst int Mod=1e9+7;\nint n,a[INF],k;\nvoid solve() \n&#123;\n    cin&gt;&gt;n&gt;&gt;k;\n    int sum3=0;\n    for (int i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;a[i];\n        sum3+=a[i];\n        sum3%=Mod;\n    &#125;\n    int Max=0,sum=0;\n    for (int i=1;i&lt;=n;i++) &#123;\n        sum=max(0ll,sum);\n        sum+=a[i];\n        Max=max(Max,sum);\n    &#125;\n    for (int i=1;i&lt;=k;i++) &#123;\n        sum3+=Max;\n        Max*=2;\n        Max%=Mod;\n        sum3%=Mod;\n    &#125;\n    cout&lt;&lt;(sum3%Mod+Mod)%Mod&lt;&lt;&quot;\\n&quot;;\n    // sum3 + Max + Max*2 + Max*3 \n&#125;\nsigned main()\n&#123;\n    ios::sync_with_stdio(false);\n    int t=0;\n    cin&gt;&gt;t;\n    while (t--)\n    &#123;\n        solve();\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1946\">Codeforces Round 936 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1946/problem/B\">B. Maximum Sum</a></p>\n<p>先求最大连续子列，后面最大连续子列多次加到原数组的和中，$max+max<em>2+max</em>3+…+sum$,类似这样</p>\n<pre><code class=\"cpp\">#include &lt;bits/stdc++.h&gt;\n#define int long long \nusing namespace std;\nconst int INF=1e6+5;\nconst int Mod=1e9+7;\nint n,a[INF],k;\nvoid solve() \n&#123;\n    cin&gt;&gt;n&gt;&gt;k;\n    int sum3=0;\n    for (int i=1;i&lt;=n;i++)\n    &#123;\n        cin&gt;&gt;a[i];\n        sum3+=a[i];\n        sum3%=Mod;\n    &#125;\n    int Max=0,sum=0;\n    for (int i=1;i&lt;=n;i++) &#123;\n        sum=max(0ll,sum);\n        sum+=a[i];\n        Max=max(Max,sum);\n    &#125;\n    for (int i=1;i&lt;=k;i++) &#123;\n        sum3+=Max;\n        Max*=2;\n        Max%=Mod;\n        sum3%=Mod;\n    &#125;\n    cout&lt;&lt;(sum3%Mod+Mod)%Mod&lt;&lt;&quot;\\n&quot;;\n    // sum3 + Max + Max*2 + Max*3 \n&#125;\nsigned main()\n&#123;\n    ios::sync_with_stdio(false);\n    int t=0;\n    cin&gt;&gt;t;\n    while (t--)\n    &#123;\n        solve();\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 937 (Div. 4) A. Stair, Peak, or Neither?","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[A. Stair, Peak, or Neither?](https://codeforces.com/contest/1950/problem/A)\n\n签到题，判断大小即可\n\n代码：\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int a,b,c;\n    while(t--)\n    {\n        cin >> a >> b >> c;\n        if(a<b)\n        {\n            if(b<c)\n                cout << \"STATR\" << \"\\n\";\n            else if(b>c)\n                cout << \"PEAK\" << \"\\n\";\n            else\n                cout << \"NONE\" << \"\\n\";\n        }\n        else\n            cout << \"NONE\" << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 937 (Div. 4)/A.Stair,Peak,or Neither.md","raw":"---\ntitle: Codeforces Round 937 (Div. 4) A. Stair, Peak, or Neither?\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 937 (Div. 4)\n---\n[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[A. Stair, Peak, or Neither?](https://codeforces.com/contest/1950/problem/A)\n\n签到题，判断大小即可\n\n代码：\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int a,b,c;\n    while(t--)\n    {\n        cin >> a >> b >> c;\n        if(a<b)\n        {\n            if(b<c)\n                cout << \"STATR\" << \"\\n\";\n            else if(b>c)\n                cout << \"PEAK\" << \"\\n\";\n            else\n                cout << \"NONE\" << \"\\n\";\n        }\n        else\n            cout << \"NONE\" << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 937 (Div. 4)/A.Stair,Peak,or Neither","published":1,"updated":"2024-10-21T05:59:05.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xs000dlgw1dm46cy56","content":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/A\">A. Stair, Peak, or Neither?</a></p>\n<p>签到题，判断大小即可</p>\n<p>代码：</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int a,b,c;\n    while(t--)\n    &#123;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        if(a&lt;b)\n        &#123;\n            if(b&lt;c)\n                cout &lt;&lt; &quot;STATR&quot; &lt;&lt; &quot;\\n&quot;;\n            else if(b&gt;c)\n                cout &lt;&lt; &quot;PEAK&quot; &lt;&lt; &quot;\\n&quot;;\n            else\n                cout &lt;&lt; &quot;NONE&quot; &lt;&lt; &quot;\\n&quot;;\n        &#125;\n        else\n            cout &lt;&lt; &quot;NONE&quot; &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/A\">A. Stair, Peak, or Neither?</a></p>\n<p>签到题，判断大小即可</p>\n<p>代码：</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int a,b,c;\n    while(t--)\n    &#123;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        if(a&lt;b)\n        &#123;\n            if(b&lt;c)\n                cout &lt;&lt; &quot;STATR&quot; &lt;&lt; &quot;\\n&quot;;\n            else if(b&gt;c)\n                cout &lt;&lt; &quot;PEAK&quot; &lt;&lt; &quot;\\n&quot;;\n            else\n                cout &lt;&lt; &quot;NONE&quot; &lt;&lt; &quot;\\n&quot;;\n        &#125;\n        else\n            cout &lt;&lt; &quot;NONE&quot; &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 934 (Div. 2) B. Equal XOR","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 934 (Div. 2)](https://codeforces.com/contest/1944)\n\n[B. Equal XOR](https://codeforces.com/contest/1944/problem/B)\n\n测试案例解释有误导性，异或运算，相同数字异或为0，每个数字都出现两次，不是两个都在一边，就是一边一个，只需要分开来输出即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n,k;\n        cin >> n >> k;\n        int a[2*n];\n        vector<int> pos[n+1];//储存出现位置的容器\n        for(int i=0;i<2*n;++i)\n        {\n            cin >> a[i];\n            pos[a[i]].push_back(i);//将a[i]的位置i记录\n        }\n        vector<int> l,r;\n        /*如果一个数字 i 在前 n 个位置出现两次,且 l 的长度小于 2k,那么就将 i 添加到 l 中两次。\n         * 如果一个数字 i 在后 n 个位置出现两次,且 r 的长度小于 2k,那么就将 i 添加到 r 中两次。*/\n        for(int i=1;i<=n;++i)//数字从1开始\n        {\n            if(pos[i].front() < n && pos[i].back() <n && l.size()<2*k)\n            {\n                l.push_back(i);\n                l.push_back(i);\n            }\n            else if(pos[i].front()>=n && pos[i].back() >=n &&r.size()<2*k)\n            {\n                r.push_back(i);\n                r.push_back(i);\n            }\n        }\n        for(int i=1;i<=n;++i)//处理剩余的数字。如果一个数字 i 在前后 n 个位置各出现一次,且 l 的长度小于 2k,那么就将 i 添加到 l 和 r 中。\n        {\n            if((pos[i].front()<n&&pos[i].back()<n) || (pos[i].front()>=n&&pos[i].back()>=n))\n            {\n                continue;\n            }\n            if(l.size()<2*k)\n            {\n                l.push_back(i);\n                r.push_back(i);\n            }\n        }\n        for(auto i : l)\n            cout << i << \" \";\n        cout << endl;\n        for(auto i : r)\n            cout << i << \" \";\n        cout << endl;\n    }\n}\n```\n\n","source":"_posts/Codeforces Round 934 (Div. 2)/B.Equal XOR.md","raw":"---\ntitle: Codeforces Round 934 (Div. 2) B. Equal XOR\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags:\n  - Codeforces Round 934 (Div. 2)\n---\n[Codeforces Round 934 (Div. 2)](https://codeforces.com/contest/1944)\n\n[B. Equal XOR](https://codeforces.com/contest/1944/problem/B)\n\n测试案例解释有误导性，异或运算，相同数字异或为0，每个数字都出现两次，不是两个都在一边，就是一边一个，只需要分开来输出即可\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n,k;\n        cin >> n >> k;\n        int a[2*n];\n        vector<int> pos[n+1];//储存出现位置的容器\n        for(int i=0;i<2*n;++i)\n        {\n            cin >> a[i];\n            pos[a[i]].push_back(i);//将a[i]的位置i记录\n        }\n        vector<int> l,r;\n        /*如果一个数字 i 在前 n 个位置出现两次,且 l 的长度小于 2k,那么就将 i 添加到 l 中两次。\n         * 如果一个数字 i 在后 n 个位置出现两次,且 r 的长度小于 2k,那么就将 i 添加到 r 中两次。*/\n        for(int i=1;i<=n;++i)//数字从1开始\n        {\n            if(pos[i].front() < n && pos[i].back() <n && l.size()<2*k)\n            {\n                l.push_back(i);\n                l.push_back(i);\n            }\n            else if(pos[i].front()>=n && pos[i].back() >=n &&r.size()<2*k)\n            {\n                r.push_back(i);\n                r.push_back(i);\n            }\n        }\n        for(int i=1;i<=n;++i)//处理剩余的数字。如果一个数字 i 在前后 n 个位置各出现一次,且 l 的长度小于 2k,那么就将 i 添加到 l 和 r 中。\n        {\n            if((pos[i].front()<n&&pos[i].back()<n) || (pos[i].front()>=n&&pos[i].back()>=n))\n            {\n                continue;\n            }\n            if(l.size()<2*k)\n            {\n                l.push_back(i);\n                r.push_back(i);\n            }\n        }\n        for(auto i : l)\n            cout << i << \" \";\n        cout << endl;\n        for(auto i : r)\n            cout << i << \" \";\n        cout << endl;\n    }\n}\n```\n\n","slug":"Codeforces Round 934 (Div. 2)/B.Equal XOR","published":1,"updated":"2024-10-21T02:46:11.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xt000glgw14cd7erqc","content":"<p><a href=\"https://codeforces.com/contest/1944\">Codeforces Round 934 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1944/problem/B\">B. Equal XOR</a></p>\n<p>测试案例解释有误导性，异或运算，相同数字异或为0，每个数字都出现两次，不是两个都在一边，就是一边一个，只需要分开来输出即可</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        int n,k;\n        cin &gt;&gt; n &gt;&gt; k;\n        int a[2*n];\n        vector&lt;int&gt; pos[n+1];//储存出现位置的容器\n        for(int i=0;i&lt;2*n;++i)\n        &#123;\n            cin &gt;&gt; a[i];\n            pos[a[i]].push_back(i);//将a[i]的位置i记录\n        &#125;\n        vector&lt;int&gt; l,r;\n        /*如果一个数字 i 在前 n 个位置出现两次,且 l 的长度小于 2k,那么就将 i 添加到 l 中两次。\n         * 如果一个数字 i 在后 n 个位置出现两次,且 r 的长度小于 2k,那么就将 i 添加到 r 中两次。*/\n        for(int i=1;i&lt;=n;++i)//数字从1开始\n        &#123;\n            if(pos[i].front() &lt; n &amp;&amp; pos[i].back() &lt;n &amp;&amp; l.size()&lt;2*k)\n            &#123;\n                l.push_back(i);\n                l.push_back(i);\n            &#125;\n            else if(pos[i].front()&gt;=n &amp;&amp; pos[i].back() &gt;=n &amp;&amp;r.size()&lt;2*k)\n            &#123;\n                r.push_back(i);\n                r.push_back(i);\n            &#125;\n        &#125;\n        for(int i=1;i&lt;=n;++i)//处理剩余的数字。如果一个数字 i 在前后 n 个位置各出现一次,且 l 的长度小于 2k,那么就将 i 添加到 l 和 r 中。\n        &#123;\n            if((pos[i].front()&lt;n&amp;&amp;pos[i].back()&lt;n) || (pos[i].front()&gt;=n&amp;&amp;pos[i].back()&gt;=n))\n            &#123;\n                continue;\n            &#125;\n            if(l.size()&lt;2*k)\n            &#123;\n                l.push_back(i);\n                r.push_back(i);\n            &#125;\n        &#125;\n        for(auto i : l)\n            cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n        for(auto i : r)\n            cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1944\">Codeforces Round 934 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1944/problem/B\">B. Equal XOR</a></p>\n<p>测试案例解释有误导性，异或运算，相同数字异或为0，每个数字都出现两次，不是两个都在一边，就是一边一个，只需要分开来输出即可</p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        int n,k;\n        cin &gt;&gt; n &gt;&gt; k;\n        int a[2*n];\n        vector&lt;int&gt; pos[n+1];//储存出现位置的容器\n        for(int i=0;i&lt;2*n;++i)\n        &#123;\n            cin &gt;&gt; a[i];\n            pos[a[i]].push_back(i);//将a[i]的位置i记录\n        &#125;\n        vector&lt;int&gt; l,r;\n        /*如果一个数字 i 在前 n 个位置出现两次,且 l 的长度小于 2k,那么就将 i 添加到 l 中两次。\n         * 如果一个数字 i 在后 n 个位置出现两次,且 r 的长度小于 2k,那么就将 i 添加到 r 中两次。*/\n        for(int i=1;i&lt;=n;++i)//数字从1开始\n        &#123;\n            if(pos[i].front() &lt; n &amp;&amp; pos[i].back() &lt;n &amp;&amp; l.size()&lt;2*k)\n            &#123;\n                l.push_back(i);\n                l.push_back(i);\n            &#125;\n            else if(pos[i].front()&gt;=n &amp;&amp; pos[i].back() &gt;=n &amp;&amp;r.size()&lt;2*k)\n            &#123;\n                r.push_back(i);\n                r.push_back(i);\n            &#125;\n        &#125;\n        for(int i=1;i&lt;=n;++i)//处理剩余的数字。如果一个数字 i 在前后 n 个位置各出现一次,且 l 的长度小于 2k,那么就将 i 添加到 l 和 r 中。\n        &#123;\n            if((pos[i].front()&lt;n&amp;&amp;pos[i].back()&lt;n) || (pos[i].front()&gt;=n&amp;&amp;pos[i].back()&gt;=n))\n            &#123;\n                continue;\n            &#125;\n            if(l.size()&lt;2*k)\n            &#123;\n                l.push_back(i);\n                r.push_back(i);\n            &#125;\n        &#125;\n        for(auto i : l)\n            cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n        for(auto i : r)\n            cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 937 (Div. 4) B. Upscaling","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[B. Upscaling](https://codeforces.com/contest/1950/problem/B)\n\n..,##交替输出两次即可\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s[2]={\"##\",\"..\"};\nint n;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;j++)\n            {\n                cout << s[(j+i)%2];\n            }\n            cout << \"\\n\";\n            for(int j=0;j<n;j++)\n            {\n                cout << s[(i+j)%2];\n            }\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 937 (Div. 4)/B.Upscaling.md","raw":"---\ntitle: Codeforces Round 937 (Div. 4) B. Upscaling\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 937 (Div. 4)\n---\n[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[B. Upscaling](https://codeforces.com/contest/1950/problem/B)\n\n..,##交替输出两次即可\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s[2]={\"##\",\"..\"};\nint n;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;j++)\n            {\n                cout << s[(j+i)%2];\n            }\n            cout << \"\\n\";\n            for(int j=0;j<n;j++)\n            {\n                cout << s[(i+j)%2];\n            }\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 937 (Div. 4)/B.Upscaling","published":1,"updated":"2024-10-21T05:59:05.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xt000hlgw1a3tvb9r5","content":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/B\">B. Upscaling</a></p>\n<p>..,##交替输出两次即可</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s[2]=&#123;&quot;##&quot;,&quot;..&quot;&#125;;\nint n;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n;\n        for(int i=0;i&lt;n;++i)\n        &#123;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                cout &lt;&lt; s[(j+i)%2];\n            &#125;\n            cout &lt;&lt; &quot;\\n&quot;;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                cout &lt;&lt; s[(i+j)%2];\n            &#125;\n            cout &lt;&lt; &quot;\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/B\">B. Upscaling</a></p>\n<p>..,##交替输出两次即可</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s[2]=&#123;&quot;##&quot;,&quot;..&quot;&#125;;\nint n;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n;\n        for(int i=0;i&lt;n;++i)\n        &#123;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                cout &lt;&lt; s[(j+i)%2];\n            &#125;\n            cout &lt;&lt; &quot;\\n&quot;;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                cout &lt;&lt; s[(i+j)%2];\n            &#125;\n            cout &lt;&lt; &quot;\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 937 (Div. 4) C. Clock Conversion","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[C. Clock Conversion](https://codeforces.com/contest/1950/problem/C)\n\n代码：\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> s;\n        string s1=s.substr(0,2);//储存小时\n        string s2=s.substr(2,3);//储存分钟\n        if(s1<\"12\"&&s1>\"00\")\n            cout << s << \" AM\\n\";\n        else if(s1==\"00\")\n            cout << \"12\" << s2 << \" AM\\n\";\n        else if(s1==\"12\")\n            cout << \"12\" << s2 << \" PM\\n\";\n        else\n        {\n            int a=10*(s1[0]-'0')+(s1[1]-'0')-12;\n            if(a<10)//22:00-12:00会出现不需要前导零的情况\n                cout << \"0\" << a << s2 << \" PM\\n\";\n            else\n                cout << a << s2 << \" PM\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n\n\n","source":"_posts/Codeforces Round 937 (Div. 4)/C.Clock Conversion.md","raw":"---\ntitle: Codeforces Round 937 (Div. 4) C. Clock Conversion\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 937 (Div. 4)\n---\n[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[C. Clock Conversion](https://codeforces.com/contest/1950/problem/C)\n\n代码：\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> s;\n        string s1=s.substr(0,2);//储存小时\n        string s2=s.substr(2,3);//储存分钟\n        if(s1<\"12\"&&s1>\"00\")\n            cout << s << \" AM\\n\";\n        else if(s1==\"00\")\n            cout << \"12\" << s2 << \" AM\\n\";\n        else if(s1==\"12\")\n            cout << \"12\" << s2 << \" PM\\n\";\n        else\n        {\n            int a=10*(s1[0]-'0')+(s1[1]-'0')-12;\n            if(a<10)//22:00-12:00会出现不需要前导零的情况\n                cout << \"0\" << a << s2 << \" PM\\n\";\n            else\n                cout << a << s2 << \" PM\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n\n\n","slug":"Codeforces Round 937 (Div. 4)/C.Clock Conversion","published":1,"updated":"2024-10-21T05:59:05.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xy0012lgw1e8ev5zvp","content":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/C\">C. Clock Conversion</a></p>\n<p>代码：</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; s;\n        string s1=s.substr(0,2);//储存小时\n        string s2=s.substr(2,3);//储存分钟\n        if(s1&lt;&quot;12&quot;&amp;&amp;s1&gt;&quot;00&quot;)\n            cout &lt;&lt; s &lt;&lt; &quot; AM\\n&quot;;\n        else if(s1==&quot;00&quot;)\n            cout &lt;&lt; &quot;12&quot; &lt;&lt; s2 &lt;&lt; &quot; AM\\n&quot;;\n        else if(s1==&quot;12&quot;)\n            cout &lt;&lt; &quot;12&quot; &lt;&lt; s2 &lt;&lt; &quot; PM\\n&quot;;\n        else\n        &#123;\n            int a=10*(s1[0]-&#39;0&#39;)+(s1[1]-&#39;0&#39;)-12;\n            if(a&lt;10)//22:00-12:00会出现不需要前导零的情况\n                cout &lt;&lt; &quot;0&quot; &lt;&lt; a &lt;&lt; s2 &lt;&lt; &quot; PM\\n&quot;;\n            else\n                cout &lt;&lt; a &lt;&lt; s2 &lt;&lt; &quot; PM\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/C\">C. Clock Conversion</a></p>\n<p>代码：</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstring s;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; s;\n        string s1=s.substr(0,2);//储存小时\n        string s2=s.substr(2,3);//储存分钟\n        if(s1&lt;&quot;12&quot;&amp;&amp;s1&gt;&quot;00&quot;)\n            cout &lt;&lt; s &lt;&lt; &quot; AM\\n&quot;;\n        else if(s1==&quot;00&quot;)\n            cout &lt;&lt; &quot;12&quot; &lt;&lt; s2 &lt;&lt; &quot; AM\\n&quot;;\n        else if(s1==&quot;12&quot;)\n            cout &lt;&lt; &quot;12&quot; &lt;&lt; s2 &lt;&lt; &quot; PM\\n&quot;;\n        else\n        &#123;\n            int a=10*(s1[0]-&#39;0&#39;)+(s1[1]-&#39;0&#39;)-12;\n            if(a&lt;10)//22:00-12:00会出现不需要前导零的情况\n                cout &lt;&lt; &quot;0&quot; &lt;&lt; a &lt;&lt; s2 &lt;&lt; &quot; PM\\n&quot;;\n            else\n                cout &lt;&lt; a &lt;&lt; s2 &lt;&lt; &quot; PM\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 946 (Div. 3) A.Phone Desktop","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 946 (Div. 3)](https://codeforces.com/contest/1974)\n\n[A.Phone Desktop](https://codeforces.com/contest/1974/problem/A)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint x,y;\nint ans;\nint room;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> x >> y;\n        ans = (y+1)/2;\n        if(y%2==0)\n        {\n            room=7*ans;\n        }\n        else\n        {\n            room=7*ans+4;\n        }\n        while(room<x)\n        {\n            room+=15;\n            ans++;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 946 (Div. 3)/A.Phone Desktop.md","raw":"---\ntitle: Codeforces Round 946 (Div. 3) A.Phone Desktop\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 946 (Div. 3)\n---\n[Codeforces Round 946 (Div. 3)](https://codeforces.com/contest/1974)\n\n[A.Phone Desktop](https://codeforces.com/contest/1974/problem/A)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint x,y;\nint ans;\nint room;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> x >> y;\n        ans = (y+1)/2;\n        if(y%2==0)\n        {\n            room=7*ans;\n        }\n        else\n        {\n            room=7*ans+4;\n        }\n        while(room<x)\n        {\n            room+=15;\n            ans++;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 946 (Div. 3)/A.Phone Desktop","published":1,"updated":"2024-10-21T05:59:05.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xy0013lgw1a1byeptx","content":"<p><a href=\"https://codeforces.com/contest/1974\">Codeforces Round 946 (Div. 3)</a></p>\n<p><a href=\"https://codeforces.com/contest/1974/problem/A\">A.Phone Desktop</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint x,y;\nint ans;\nint room;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        ans = (y+1)/2;\n        if(y%2==0)\n        &#123;\n            room=7*ans;\n        &#125;\n        else\n        &#123;\n            room=7*ans+4;\n        &#125;\n        while(room&lt;x)\n        &#123;\n            room+=15;\n            ans++;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1974\">Codeforces Round 946 (Div. 3)</a></p>\n<p><a href=\"https://codeforces.com/contest/1974/problem/A\">A.Phone Desktop</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint x,y;\nint ans;\nint room;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        ans = (y+1)/2;\n        if(y%2==0)\n        &#123;\n            room=7*ans;\n        &#125;\n        else\n        &#123;\n            room=7*ans+4;\n        &#125;\n        while(room&lt;x)\n        &#123;\n            room+=15;\n            ans++;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 946 (Div. 3) B.Symmetric Encoding","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 946 (Div. 3)](https://codeforces.com/contest/1974)\n\n[B.Symmetric Encoding](https://codeforces.com/contest/1974/problem/B)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring b;\nset<char> s;\nint n;\nchar v[26];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        cin >> b;\n        string ans;\n        for(auto c : b)\n        {\n            s.insert(c);\n        }\n        auto j=s.end();\n        j--;\n        for(char i : s)\n        {\n            v[i-'a']=*j;\n            j--;\n        }\n        for(auto c:b)\n        {\n            ans+=v[c-'a'];\n        }\n        s.clear();\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 946 (Div. 3)/B.Symmetric Encoding.md","raw":"---\ntitle: Codeforces Round 946 (Div. 3) B.Symmetric Encoding\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 946 (Div. 3)\n---\n[Codeforces Round 946 (Div. 3)](https://codeforces.com/contest/1974)\n\n[B.Symmetric Encoding](https://codeforces.com/contest/1974/problem/B)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring b;\nset<char> s;\nint n;\nchar v[26];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        cin >> b;\n        string ans;\n        for(auto c : b)\n        {\n            s.insert(c);\n        }\n        auto j=s.end();\n        j--;\n        for(char i : s)\n        {\n            v[i-'a']=*j;\n            j--;\n        }\n        for(auto c:b)\n        {\n            ans+=v[c-'a'];\n        }\n        s.clear();\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 946 (Div. 3)/B.Symmetric Encoding","published":1,"updated":"2024-10-21T05:59:05.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xz0015lgw1cb6tbpeg","content":"<p><a href=\"https://codeforces.com/contest/1974\">Codeforces Round 946 (Div. 3)</a></p>\n<p><a href=\"https://codeforces.com/contest/1974/problem/B\">B.Symmetric Encoding</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring b;\nset&lt;char&gt; s;\nint n;\nchar v[26];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n;\n        cin &gt;&gt; b;\n        string ans;\n        for(auto c : b)\n        &#123;\n            s.insert(c);\n        &#125;\n        auto j=s.end();\n        j--;\n        for(char i : s)\n        &#123;\n            v[i-&#39;a&#39;]=*j;\n            j--;\n        &#125;\n        for(auto c:b)\n        &#123;\n            ans+=v[c-&#39;a&#39;];\n        &#125;\n        s.clear();\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1974\">Codeforces Round 946 (Div. 3)</a></p>\n<p><a href=\"https://codeforces.com/contest/1974/problem/B\">B.Symmetric Encoding</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring b;\nset&lt;char&gt; s;\nint n;\nchar v[26];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n;\n        cin &gt;&gt; b;\n        string ans;\n        for(auto c : b)\n        &#123;\n            s.insert(c);\n        &#125;\n        auto j=s.end();\n        j--;\n        for(char i : s)\n        &#123;\n            v[i-&#39;a&#39;]=*j;\n            j--;\n        &#125;\n        for(auto c:b)\n        &#123;\n            ans+=v[c-&#39;a&#39;];\n        &#125;\n        s.clear();\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 937 (Div. 4) D. Product of Binary Decimals","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[D. Product of Binary Decimals](https://codeforces.com/contest/1950/problem/D)\n\n本人使用了朴实无华的打表，从最大的开始代入遍历\n\n代码：\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint a[30]={10,11,100,101,110,\n          111,1000,1001,1010,1011,\n          1100,1101,1110,1111,10000,\n          10001,10010,10011,10100,10101,\n          10110,10111,11000,11001,11010,\n          11011,11100,11101,11110,11111};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        bool flag=false;\n        if(n==1)\n            flag= true;\n        else\n        {\n            for(int i=29;i>=0&&n>1;i--)\n            {\n                if(n%a[i]==0)\n                {\n                    flag=true;\n                    n=n/a[i];\n                    i=29;//n改变，故从头再判断遍历\n                }\n                else\n                    flag= false;\n            }\n        }\n        if(flag)\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 937 (Div. 4)/D.Product of Binary Decimals.md","raw":"---\ntitle: Codeforces Round 937 (Div. 4) D. Product of Binary Decimals\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 937 (Div. 4)\n---\n[Codeforces Round 937 (Div. 4)](https://codeforces.com/contest/1950)\n\n[D. Product of Binary Decimals](https://codeforces.com/contest/1950/problem/D)\n\n本人使用了朴实无华的打表，从最大的开始代入遍历\n\n代码：\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint a[30]={10,11,100,101,110,\n          111,1000,1001,1010,1011,\n          1100,1101,1110,1111,10000,\n          10001,10010,10011,10100,10101,\n          10110,10111,11000,11001,11010,\n          11011,11100,11101,11110,11111};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        bool flag=false;\n        if(n==1)\n            flag= true;\n        else\n        {\n            for(int i=29;i>=0&&n>1;i--)\n            {\n                if(n%a[i]==0)\n                {\n                    flag=true;\n                    n=n/a[i];\n                    i=29;//n改变，故从头再判断遍历\n                }\n                else\n                    flag= false;\n            }\n        }\n        if(flag)\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 937 (Div. 4)/D.Product of Binary Decimals","published":1,"updated":"2024-10-21T05:59:05.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0xz0017lgw10qdj7g52","content":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/D\">D. Product of Binary Decimals</a></p>\n<p>本人使用了朴实无华的打表，从最大的开始代入遍历</p>\n<p>代码：</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint a[30]=&#123;10,11,100,101,110,\n          111,1000,1001,1010,1011,\n          1100,1101,1110,1111,10000,\n          10001,10010,10011,10100,10101,\n          10110,10111,11000,11001,11010,\n          11011,11100,11101,11110,11111&#125;;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        int n;\n        cin &gt;&gt; n;\n        bool flag=false;\n        if(n==1)\n            flag= true;\n        else\n        &#123;\n            for(int i=29;i&gt;=0&amp;&amp;n&gt;1;i--)\n            &#123;\n                if(n%a[i]==0)\n                &#123;\n                    flag=true;\n                    n=n/a[i];\n                    i=29;//n改变，故从头再判断遍历\n                &#125;\n                else\n                    flag= false;\n            &#125;\n        &#125;\n        if(flag)\n            cout &lt;&lt; &quot;YES\\n&quot;;\n        else\n            cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1950\">Codeforces Round 937 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1950/problem/D\">D. Product of Binary Decimals</a></p>\n<p>本人使用了朴实无华的打表，从最大的开始代入遍历</p>\n<p>代码：</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nint a[30]=&#123;10,11,100,101,110,\n          111,1000,1001,1010,1011,\n          1100,1101,1110,1111,10000,\n          10001,10010,10011,10100,10101,\n          10110,10111,11000,11001,11010,\n          11011,11100,11101,11110,11111&#125;;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        int n;\n        cin &gt;&gt; n;\n        bool flag=false;\n        if(n==1)\n            flag= true;\n        else\n        &#123;\n            for(int i=29;i&gt;=0&amp;&amp;n&gt;1;i--)\n            &#123;\n                if(n%a[i]==0)\n                &#123;\n                    flag=true;\n                    n=n/a[i];\n                    i=29;//n改变，故从头再判断遍历\n                &#125;\n                else\n                    flag= false;\n            &#125;\n        &#125;\n        if(flag)\n            cout &lt;&lt; &quot;YES\\n&quot;;\n        else\n            cout &lt;&lt; &quot;NO\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 944 (Div. 4) A. My First Sorting Problem","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[A. My First Sorting Problem](https://codeforces.com/contest/1971/problem/A)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int x,y;\n    while(t--)\n    {\n        cin >> x >> y;\n        if(x<y)\n            cout << x << \" \" << y;\n        else\n            cout << y << \" \" << x;\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 944 (Div. 4)/A. My First Sorting Problem.md","raw":"---\ntitle: Codeforces Round 944 (Div. 4) A. My First Sorting Problem\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 944 (Div. 4)\n---\n[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[A. My First Sorting Problem](https://codeforces.com/contest/1971/problem/A)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int x,y;\n    while(t--)\n    {\n        cin >> x >> y;\n        if(x<y)\n            cout << x << \" \" << y;\n        else\n            cout << y << \" \" << x;\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 944 (Div. 4)/A. My First Sorting Problem","published":1,"updated":"2024-10-21T05:59:05.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y00019lgw1b11pbs8m","content":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/A\">A. My First Sorting Problem</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int x,y;\n    while(t--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        if(x&lt;y)\n            cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y;\n        else\n            cout &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; x;\n        cout &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/A\">A. My First Sorting Problem</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int x,y;\n    while(t--)\n    &#123;\n        cin &gt;&gt; x &gt;&gt; y;\n        if(x&lt;y)\n            cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y;\n        else\n            cout &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; x;\n        cout &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 946 (Div. 3) C.Beautiful Triple Pairs","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 946 (Div. 3)](https://codeforces.com/contest/1974)\n\n[C.Beautiful Triple Pairs](https://codeforces.com/contest/1974/problem/C)\n\n代码的主要作用是计算在给定的多个测试用例中，每个测试用例的数组中特定模式（对和三元组）出现的次数，并对这些模式出现的次数进行加减操作以得到最终结果。\n\n具体步骤如下：\n\n1. 读取测试用例数量 `t`。\n2. 对于每个测试用例，使用两个 `map` 分别记录三元组和二维对的出现次数。\n3. 读取数组长度 `n` 和数组元素。\n4. 初始化结果 `res` 为 0。\n5. 从数组的第三个元素开始遍历：\n   - 计算并增加以当前元素为结尾的不同模式的对的出现次数。\n   - 减去当前三元组出现次数的三倍（避免重复计数）。\n6. 将最终结果输出。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n// 定义一些全局变量\nint i,j,k,n,m,t,a[1005000];\nll res;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\t// 读取测试用例数量\n\tcin >> t;\n\twhile(t--){\n\t\t// 定义两个map，一个用于存储三元组，一个用于存储二维对\n\t\tmap<tuple<int, int, int>, int> mp1;\n\t\tmap<pair<int, int>, int> mp[4];\n\t\t// 读取数组的大小\n\t\tcin >> n;\n\t\t// 读取数组元素\n\t\tfor(i = 1; i <= n; i++) cin >> a[i];\n\t\t// 初始化结果\n\t\tres = 0;\n\t\t// 从第3个元素开始处理，因为至少需要前两个元素\n\t\tfor(i = 3; i <= n; i++){\n\t\t\t// 统计以a[i-1]和a[i]为结尾的对出现的次数\n\t\t\tres += mp[1][{a[i-1], a[i]}]++;\n\t\t\t// 统计以a[i-2]和a[i]为结尾的对出现的次数\n\t\t\tres += mp[2][{a[i-2], a[i]}]++;\n\t\t\t// 统计以a[i-1]和a[i-2]为结尾的对出现的次数\n\t\t\tres += mp[3][{a[i-1], a[i-2]}]++;\n\t\t\t// 减去出现的三元组(a[i-2], a[i-1], a[i])的三倍次数\n\t\t\tres -= mp1[{a[i-2], a[i-1], a[i]}] * 3;\n\t\t\t// 增加当前三元组的计数\n\t\t\tmp1[{a[i-2], a[i-1], a[i]}]++;\n\t\t}\n\t\t// 输出结果\n\t\tcout << res << '\\n';\n\t}\n}\n\n```\n\n","source":"_posts/Codeforces Round 946 (Div. 3)/C. Beautiful Triple Pairs.md","raw":"---\ntitle: Codeforces Round 946 (Div. 3) C.Beautiful Triple Pairs\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 946 (Div. 3)\n---\n[Codeforces Round 946 (Div. 3)](https://codeforces.com/contest/1974)\n\n[C.Beautiful Triple Pairs](https://codeforces.com/contest/1974/problem/C)\n\n代码的主要作用是计算在给定的多个测试用例中，每个测试用例的数组中特定模式（对和三元组）出现的次数，并对这些模式出现的次数进行加减操作以得到最终结果。\n\n具体步骤如下：\n\n1. 读取测试用例数量 `t`。\n2. 对于每个测试用例，使用两个 `map` 分别记录三元组和二维对的出现次数。\n3. 读取数组长度 `n` 和数组元素。\n4. 初始化结果 `res` 为 0。\n5. 从数组的第三个元素开始遍历：\n   - 计算并增加以当前元素为结尾的不同模式的对的出现次数。\n   - 减去当前三元组出现次数的三倍（避免重复计数）。\n6. 将最终结果输出。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n// 定义一些全局变量\nint i,j,k,n,m,t,a[1005000];\nll res;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0);\n\t// 读取测试用例数量\n\tcin >> t;\n\twhile(t--){\n\t\t// 定义两个map，一个用于存储三元组，一个用于存储二维对\n\t\tmap<tuple<int, int, int>, int> mp1;\n\t\tmap<pair<int, int>, int> mp[4];\n\t\t// 读取数组的大小\n\t\tcin >> n;\n\t\t// 读取数组元素\n\t\tfor(i = 1; i <= n; i++) cin >> a[i];\n\t\t// 初始化结果\n\t\tres = 0;\n\t\t// 从第3个元素开始处理，因为至少需要前两个元素\n\t\tfor(i = 3; i <= n; i++){\n\t\t\t// 统计以a[i-1]和a[i]为结尾的对出现的次数\n\t\t\tres += mp[1][{a[i-1], a[i]}]++;\n\t\t\t// 统计以a[i-2]和a[i]为结尾的对出现的次数\n\t\t\tres += mp[2][{a[i-2], a[i]}]++;\n\t\t\t// 统计以a[i-1]和a[i-2]为结尾的对出现的次数\n\t\t\tres += mp[3][{a[i-1], a[i-2]}]++;\n\t\t\t// 减去出现的三元组(a[i-2], a[i-1], a[i])的三倍次数\n\t\t\tres -= mp1[{a[i-2], a[i-1], a[i]}] * 3;\n\t\t\t// 增加当前三元组的计数\n\t\t\tmp1[{a[i-2], a[i-1], a[i]}]++;\n\t\t}\n\t\t// 输出结果\n\t\tcout << res << '\\n';\n\t}\n}\n\n```\n\n","slug":"Codeforces Round 946 (Div. 3)/C. Beautiful Triple Pairs","published":1,"updated":"2024-10-21T05:59:05.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y0001clgw1dhxscni7","content":"<p><a href=\"https://codeforces.com/contest/1974\">Codeforces Round 946 (Div. 3)</a></p>\n<p><a href=\"https://codeforces.com/contest/1974/problem/C\">C.Beautiful Triple Pairs</a></p>\n<p>代码的主要作用是计算在给定的多个测试用例中，每个测试用例的数组中特定模式（对和三元组）出现的次数，并对这些模式出现的次数进行加减操作以得到最终结果。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li>读取测试用例数量 <code>t</code>。</li>\n<li>对于每个测试用例，使用两个 <code>map</code> 分别记录三元组和二维对的出现次数。</li>\n<li>读取数组长度 <code>n</code> 和数组元素。</li>\n<li>初始化结果 <code>res</code> 为 0。</li>\n<li>从数组的第三个元素开始遍历：<ul>\n<li>计算并增加以当前元素为结尾的不同模式的对的出现次数。</li>\n<li>减去当前三元组出现次数的三倍（避免重复计数）。</li>\n</ul>\n</li>\n<li>将最终结果输出。</li>\n</ol>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\n// 定义一些全局变量\nint i,j,k,n,m,t,a[1005000];\nll res;\n\nint main()&#123;\n    ios::sync_with_stdio(0); cin.tie(0);\n    // 读取测试用例数量\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        // 定义两个map，一个用于存储三元组，一个用于存储二维对\n        map&lt;tuple&lt;int, int, int&gt;, int&gt; mp1;\n        map&lt;pair&lt;int, int&gt;, int&gt; mp[4];\n        // 读取数组的大小\n        cin &gt;&gt; n;\n        // 读取数组元素\n        for(i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n        // 初始化结果\n        res = 0;\n        // 从第3个元素开始处理，因为至少需要前两个元素\n        for(i = 3; i &lt;= n; i++)&#123;\n            // 统计以a[i-1]和a[i]为结尾的对出现的次数\n            res += mp[1][&#123;a[i-1], a[i]&#125;]++;\n            // 统计以a[i-2]和a[i]为结尾的对出现的次数\n            res += mp[2][&#123;a[i-2], a[i]&#125;]++;\n            // 统计以a[i-1]和a[i-2]为结尾的对出现的次数\n            res += mp[3][&#123;a[i-1], a[i-2]&#125;]++;\n            // 减去出现的三元组(a[i-2], a[i-1], a[i])的三倍次数\n            res -= mp1[&#123;a[i-2], a[i-1], a[i]&#125;] * 3;\n            // 增加当前三元组的计数\n            mp1[&#123;a[i-2], a[i-1], a[i]&#125;]++;\n        &#125;\n        // 输出结果\n        cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1974\">Codeforces Round 946 (Div. 3)</a></p>\n<p><a href=\"https://codeforces.com/contest/1974/problem/C\">C.Beautiful Triple Pairs</a></p>\n<p>代码的主要作用是计算在给定的多个测试用例中，每个测试用例的数组中特定模式（对和三元组）出现的次数，并对这些模式出现的次数进行加减操作以得到最终结果。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li>读取测试用例数量 <code>t</code>。</li>\n<li>对于每个测试用例，使用两个 <code>map</code> 分别记录三元组和二维对的出现次数。</li>\n<li>读取数组长度 <code>n</code> 和数组元素。</li>\n<li>初始化结果 <code>res</code> 为 0。</li>\n<li>从数组的第三个元素开始遍历：<ul>\n<li>计算并增加以当前元素为结尾的不同模式的对的出现次数。</li>\n<li>减去当前三元组出现次数的三倍（避免重复计数）。</li>\n</ul>\n</li>\n<li>将最终结果输出。</li>\n</ol>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\n// 定义一些全局变量\nint i,j,k,n,m,t,a[1005000];\nll res;\n\nint main()&#123;\n    ios::sync_with_stdio(0); cin.tie(0);\n    // 读取测试用例数量\n    cin &gt;&gt; t;\n    while(t--)&#123;\n        // 定义两个map，一个用于存储三元组，一个用于存储二维对\n        map&lt;tuple&lt;int, int, int&gt;, int&gt; mp1;\n        map&lt;pair&lt;int, int&gt;, int&gt; mp[4];\n        // 读取数组的大小\n        cin &gt;&gt; n;\n        // 读取数组元素\n        for(i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n        // 初始化结果\n        res = 0;\n        // 从第3个元素开始处理，因为至少需要前两个元素\n        for(i = 3; i &lt;= n; i++)&#123;\n            // 统计以a[i-1]和a[i]为结尾的对出现的次数\n            res += mp[1][&#123;a[i-1], a[i]&#125;]++;\n            // 统计以a[i-2]和a[i]为结尾的对出现的次数\n            res += mp[2][&#123;a[i-2], a[i]&#125;]++;\n            // 统计以a[i-1]和a[i-2]为结尾的对出现的次数\n            res += mp[3][&#123;a[i-1], a[i-2]&#125;]++;\n            // 减去出现的三元组(a[i-2], a[i-1], a[i])的三倍次数\n            res -= mp1[&#123;a[i-2], a[i-1], a[i]&#125;] * 3;\n            // 增加当前三元组的计数\n            mp1[&#123;a[i-2], a[i-1], a[i]&#125;]++;\n        &#125;\n        // 输出结果\n        cout &lt;&lt; res &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 934 (Div. 2) C. MEX Game 1","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 934 (Div. 2)](https://codeforces.com/contest/1944)\n\n[C. MEX Game 1](https://codeforces.com/contest/1944/problem/C)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=1e6;\nint g[Max];\nint read() //快速读入函数\n{\n    int s = 0,f = 1;char ch = getchar();\n    while (!isdigit(ch)) f = ch == '-'? -1 : 1, ch = getchar();\n    while(isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();\n    return s * f;\n}\nint main()\n{\n    int t=read();\n    while(t--)\n    {\n        int n=read();\n        for(int i=0;i<=n;i++)\n            g[i]=0;\n        for(int i=1;i<=n;i++)\n        {\n            g[read()]++;//储存每个数字的出现次数\n        }\n        bool flag = false;//记录状态\n        int mex;\n        for(int i=0;i<=n;i++)//i需要小于等于n的区间循环\n        {\n            if(!g[i])\n            {\n                mex=i;\n                break;\n            }\n            if(g[i]==1)\n            {\n                if(flag)\n                {\n                    mex=i;\n                    break;\n                }\n                flag=true;//第一次出现单次出现的数，被爱丽丝拿走，故下次被bob拿走\n            }\n        }\n        printf(\"%d\\n\",mex);\n    }\n}\n```\n\n","source":"_posts/Codeforces Round 934 (Div. 2)/C.MEXGame1.md","raw":"---\ntitle: Codeforces Round 934 (Div. 2) C. MEX Game 1\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 934 (Div. 2)\n---\n[Codeforces Round 934 (Div. 2)](https://codeforces.com/contest/1944)\n\n[C. MEX Game 1](https://codeforces.com/contest/1944/problem/C)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=1e6;\nint g[Max];\nint read() //快速读入函数\n{\n    int s = 0,f = 1;char ch = getchar();\n    while (!isdigit(ch)) f = ch == '-'? -1 : 1, ch = getchar();\n    while(isdigit(ch)) s = s * 10 + ch - '0', ch = getchar();\n    return s * f;\n}\nint main()\n{\n    int t=read();\n    while(t--)\n    {\n        int n=read();\n        for(int i=0;i<=n;i++)\n            g[i]=0;\n        for(int i=1;i<=n;i++)\n        {\n            g[read()]++;//储存每个数字的出现次数\n        }\n        bool flag = false;//记录状态\n        int mex;\n        for(int i=0;i<=n;i++)//i需要小于等于n的区间循环\n        {\n            if(!g[i])\n            {\n                mex=i;\n                break;\n            }\n            if(g[i]==1)\n            {\n                if(flag)\n                {\n                    mex=i;\n                    break;\n                }\n                flag=true;//第一次出现单次出现的数，被爱丽丝拿走，故下次被bob拿走\n            }\n        }\n        printf(\"%d\\n\",mex);\n    }\n}\n```\n\n","slug":"Codeforces Round 934 (Div. 2)/C.MEXGame1","published":1,"updated":"2024-10-21T02:46:11.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y1001glgw1aowoa45r","content":"<p><a href=\"https://codeforces.com/contest/1944\">Codeforces Round 934 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1944/problem/C\">C. MEX Game 1</a></p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int Max=1e6;\nint g[Max];\nint read() //快速读入函数\n&#123;\n    int s = 0,f = 1;char ch = getchar();\n    while (!isdigit(ch)) f = ch == &#39;-&#39;? -1 : 1, ch = getchar();\n    while(isdigit(ch)) s = s * 10 + ch - &#39;0&#39;, ch = getchar();\n    return s * f;\n&#125;\nint main()\n&#123;\n    int t=read();\n    while(t--)\n    &#123;\n        int n=read();\n        for(int i=0;i&lt;=n;i++)\n            g[i]=0;\n        for(int i=1;i&lt;=n;i++)\n        &#123;\n            g[read()]++;//储存每个数字的出现次数\n        &#125;\n        bool flag = false;//记录状态\n        int mex;\n        for(int i=0;i&lt;=n;i++)//i需要小于等于n的区间循环\n        &#123;\n            if(!g[i])\n            &#123;\n                mex=i;\n                break;\n            &#125;\n            if(g[i]==1)\n            &#123;\n                if(flag)\n                &#123;\n                    mex=i;\n                    break;\n                &#125;\n                flag=true;//第一次出现单次出现的数，被爱丽丝拿走，故下次被bob拿走\n            &#125;\n        &#125;\n        printf(&quot;%d\\n&quot;,mex);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1944\">Codeforces Round 934 (Div. 2)</a></p>\n<p><a href=\"https://codeforces.com/contest/1944/problem/C\">C. MEX Game 1</a></p>\n<pre><code class=\"cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int Max=1e6;\nint g[Max];\nint read() //快速读入函数\n&#123;\n    int s = 0,f = 1;char ch = getchar();\n    while (!isdigit(ch)) f = ch == &#39;-&#39;? -1 : 1, ch = getchar();\n    while(isdigit(ch)) s = s * 10 + ch - &#39;0&#39;, ch = getchar();\n    return s * f;\n&#125;\nint main()\n&#123;\n    int t=read();\n    while(t--)\n    &#123;\n        int n=read();\n        for(int i=0;i&lt;=n;i++)\n            g[i]=0;\n        for(int i=1;i&lt;=n;i++)\n        &#123;\n            g[read()]++;//储存每个数字的出现次数\n        &#125;\n        bool flag = false;//记录状态\n        int mex;\n        for(int i=0;i&lt;=n;i++)//i需要小于等于n的区间循环\n        &#123;\n            if(!g[i])\n            &#123;\n                mex=i;\n                break;\n            &#125;\n            if(g[i]==1)\n            &#123;\n                if(flag)\n                &#123;\n                    mex=i;\n                    break;\n                &#125;\n                flag=true;//第一次出现单次出现的数，被爱丽丝拿走，故下次被bob拿走\n            &#125;\n        &#125;\n        printf(&quot;%d\\n&quot;,mex);\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 944 (Div. 4) B. Different String","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[B. Different String](https://codeforces.com/contest/1971/problem/B)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nchar tmp;\nbool flag;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> s;\n        if(s.size()<=1)\n        {\n            cout << \"NO\\n\";\n            continue;\n        }\n        flag=false;\n        for(int i=1;i<s.size();++i)\n        {\n            if(s[i]!=s[i-1])\n            {\n                tmp=s[i-1];\n                s[i-1]=s[i];\n                s[i]=tmp;\n                flag=true;\n                break;\n            }\n        }\n        if(flag)\n        {\n            cout << \"YES\\n\" << s << \"\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 944 (Div. 4)/B. Different String.md","raw":"---\ntitle: Codeforces Round 944 (Div. 4) B. Different String\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 944 (Div. 4)\n---\n[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[B. Different String](https://codeforces.com/contest/1971/problem/B)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nchar tmp;\nbool flag;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> s;\n        if(s.size()<=1)\n        {\n            cout << \"NO\\n\";\n            continue;\n        }\n        flag=false;\n        for(int i=1;i<s.size();++i)\n        {\n            if(s[i]!=s[i-1])\n            {\n                tmp=s[i-1];\n                s[i-1]=s[i];\n                s[i]=tmp;\n                flag=true;\n                break;\n            }\n        }\n        if(flag)\n        {\n            cout << \"YES\\n\" << s << \"\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 944 (Div. 4)/B. Different String","published":1,"updated":"2024-10-21T05:59:05.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y1001jlgw1ctwn7izq","content":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/B\">B. Different String</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nchar tmp;\nbool flag;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; s;\n        if(s.size()&lt;=1)\n        &#123;\n            cout &lt;&lt; &quot;NO\\n&quot;;\n            continue;\n        &#125;\n        flag=false;\n        for(int i=1;i&lt;s.size();++i)\n        &#123;\n            if(s[i]!=s[i-1])\n            &#123;\n                tmp=s[i-1];\n                s[i-1]=s[i];\n                s[i]=tmp;\n                flag=true;\n                break;\n            &#125;\n        &#125;\n        if(flag)\n        &#123;\n            cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; s &lt;&lt; &quot;\\n&quot;;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;NO\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/B\">B. Different String</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nchar tmp;\nbool flag;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; s;\n        if(s.size()&lt;=1)\n        &#123;\n            cout &lt;&lt; &quot;NO\\n&quot;;\n            continue;\n        &#125;\n        flag=false;\n        for(int i=1;i&lt;s.size();++i)\n        &#123;\n            if(s[i]!=s[i-1])\n            &#123;\n                tmp=s[i-1];\n                s[i-1]=s[i];\n                s[i]=tmp;\n                flag=true;\n                break;\n            &#125;\n        &#125;\n        if(flag)\n        &#123;\n            cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; s &lt;&lt; &quot;\\n&quot;;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;NO\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 944 (Div. 4) D. Binary Cut","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[D. Binary Cut](https://codeforces.com/contest/1971/problem/D)\n\n遇到 **'10'** 分割一次,**'01'** 分割 **n-1(n为'01'出现次数)** 次\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nint ans;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> s;\n        ans=1;\n        if(s.size()<=1)\n        {\n            cout << ans << \"\\n\";\n            continue;\n        }\n        for(int i=1;i<s.size();++i)\n        {\n            if(s[i-1]=='1'&&s[i]=='0')\n            {\n                ans++;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 944 (Div. 4)/D. Binary Cut.md","raw":"---\ntitle: Codeforces Round 944 (Div. 4) D. Binary Cut\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 944 (Div. 4)\n---\n[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[D. Binary Cut](https://codeforces.com/contest/1971/problem/D)\n\n遇到 **'10'** 分割一次,**'01'** 分割 **n-1(n为'01'出现次数)** 次\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nint ans;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> s;\n        ans=1;\n        if(s.size()<=1)\n        {\n            cout << ans << \"\\n\";\n            continue;\n        }\n        for(int i=1;i<s.size();++i)\n        {\n            if(s[i-1]=='1'&&s[i]=='0')\n            {\n                ans++;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 944 (Div. 4)/D. Binary Cut","published":1,"updated":"2024-10-21T06:03:23.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y2001nlgw1fvcg67ax","content":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/D\">D. Binary Cut</a></p>\n<p>遇到 <strong>‘10’</strong> 分割一次,<strong>‘01’</strong> 分割 <strong>n-1(n为’01’出现次数)</strong> 次</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nint ans;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; s;\n        ans=1;\n        if(s.size()&lt;=1)\n        &#123;\n            cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n            continue;\n        &#125;\n        for(int i=1;i&lt;s.size();++i)\n        &#123;\n            if(s[i-1]==&#39;1&#39;&amp;&amp;s[i]==&#39;0&#39;)\n            &#123;\n                ans++;\n            &#125;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/D\">D. Binary Cut</a></p>\n<p>遇到 <strong>‘10’</strong> 分割一次,<strong>‘01’</strong> 分割 <strong>n-1(n为’01’出现次数)</strong> 次</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nstring s;\nint ans;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; s;\n        ans=1;\n        if(s.size()&lt;=1)\n        &#123;\n            cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n            continue;\n        &#125;\n        for(int i=1;i&lt;s.size();++i)\n        &#123;\n            if(s[i-1]==&#39;1&#39;&amp;&amp;s[i]==&#39;0&#39;)\n            &#123;\n                ans++;\n            &#125;\n        &#125;\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 944 (Div. 4) C. Clock and Strings","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[C. Clock and Strings](https://codeforces.com/contest/1971/problem/C)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nbool ans[13];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int a,b,c,d,tmp;\n    while(t--)\n    {\n        cin >> a >> b >> c >> d;\n        memset(ans, false,sizeof ans);\n        if(a==c||a==d||b==c||b==d)\n        {\n            cout << \"YES\\n\";\n            continue;\n        }\n        if(a>b)\n        {\n            tmp=a;\n            a=b;\n            b=tmp;\n        }\n        for(int i=a+1;i<b;++i)\n        {\n            ans[i]=true;\n        }\n        if((ans[c]&&!ans[d])||(!ans[c]&&ans[d]))\n        {\n            cout << \"YES\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 944 (Div. 4)/C. Clock and Strings.md","raw":"---\ntitle: Codeforces Round 944 (Div. 4) C. Clock and Strings\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 944 (Div. 4)\n---\n[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[C. Clock and Strings](https://codeforces.com/contest/1971/problem/C)\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nbool ans[13];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    int a,b,c,d,tmp;\n    while(t--)\n    {\n        cin >> a >> b >> c >> d;\n        memset(ans, false,sizeof ans);\n        if(a==c||a==d||b==c||b==d)\n        {\n            cout << \"YES\\n\";\n            continue;\n        }\n        if(a>b)\n        {\n            tmp=a;\n            a=b;\n            b=tmp;\n        }\n        for(int i=a+1;i<b;++i)\n        {\n            ans[i]=true;\n        }\n        if((ans[c]&&!ans[d])||(!ans[c]&&ans[d]))\n        {\n            cout << \"YES\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 944 (Div. 4)/C. Clock and Strings","published":1,"updated":"2024-10-21T05:59:05.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y2001qlgw1b57199gi","content":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/C\">C. Clock and Strings</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nbool ans[13];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int a,b,c,d,tmp;\n    while(t--)\n    &#123;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        memset(ans, false,sizeof ans);\n        if(a==c||a==d||b==c||b==d)\n        &#123;\n            cout &lt;&lt; &quot;YES\\n&quot;;\n            continue;\n        &#125;\n        if(a&gt;b)\n        &#123;\n            tmp=a;\n            a=b;\n            b=tmp;\n        &#125;\n        for(int i=a+1;i&lt;b;++i)\n        &#123;\n            ans[i]=true;\n        &#125;\n        if((ans[c]&amp;&amp;!ans[d])||(!ans[c]&amp;&amp;ans[d]))\n        &#123;\n            cout &lt;&lt; &quot;YES\\n&quot;;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;NO\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/C\">C. Clock and Strings</a></p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nbool ans[13];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    int a,b,c,d,tmp;\n    while(t--)\n    &#123;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n        memset(ans, false,sizeof ans);\n        if(a==c||a==d||b==c||b==d)\n        &#123;\n            cout &lt;&lt; &quot;YES\\n&quot;;\n            continue;\n        &#125;\n        if(a&gt;b)\n        &#123;\n            tmp=a;\n            a=b;\n            b=tmp;\n        &#125;\n        for(int i=a+1;i&lt;b;++i)\n        &#123;\n            ans[i]=true;\n        &#125;\n        if((ans[c]&amp;&amp;!ans[d])||(!ans[c]&amp;&amp;ans[d]))\n        &#123;\n            cout &lt;&lt; &quot;YES\\n&quot;;\n        &#125;\n        else\n        &#123;\n            cout &lt;&lt; &quot;NO\\n&quot;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"},{"title":"Codeforces Round 944 (Div. 4) E. Find the Car","date":"2024-10-21T02:32:00.000Z","_content":"[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[E. Find the Car](https://codeforces.com/contest/1971/problem/E)\n\n计算时必须先乘后除\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint n,k,q,d;\nll a[N],b[N];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n >> k >> q;\n        for(int i=1;i<=k;++i)\n        {\n            cin >> a[i];\n        }\n        for(int i=1;i<=k;++i)\n        {\n            cin >> b[i];\n        }\n        while(q--)\n        {\n            cin >> d;\n            if(d==0)\n            {\n                cout << 0 << \" \";\n                continue;\n            }\n            ll i = lower_bound(a,a+k+1,d)-a;\n            ll b_left=b[i-1],b_right=b[i];\n            cout << b_left + (b_right-b_left) * (d-a[i-1]) / (a[i]-a[i-1])  << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Codeforces Round 944 (Div. 4)/E. Find the Car.md","raw":"---\ntitle: Codeforces Round 944 (Div. 4) E. Find the Car\ndate: 2024-10-21 10:32\ncategories:\n  - Codeforces\ntags: \n  - Codeforces Round 944 (Div. 4)\n---\n[Codeforces Round 944 (Div. 4)](https://codeforces.com/contest/1971)\n\n[E. Find the Car](https://codeforces.com/contest/1971/problem/E)\n\n计算时必须先乘后除\n\n```cpp\n// By SnowDream\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint n,k,q,d;\nll a[N],b[N];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        cin >> n >> k >> q;\n        for(int i=1;i<=k;++i)\n        {\n            cin >> a[i];\n        }\n        for(int i=1;i<=k;++i)\n        {\n            cin >> b[i];\n        }\n        while(q--)\n        {\n            cin >> d;\n            if(d==0)\n            {\n                cout << 0 << \" \";\n                continue;\n            }\n            ll i = lower_bound(a,a+k+1,d)-a;\n            ll b_left=b[i-1],b_right=b[i];\n            cout << b_left + (b_right-b_left) * (d-a[i-1]) / (a[i]-a[i-1])  << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n\n","slug":"Codeforces Round 944 (Div. 4)/E. Find the Car","published":1,"updated":"2024-10-21T05:59:05.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2mlm0y3001ulgw1ectt5rtg","content":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/E\">E. Find the Car</a></p>\n<p>计算时必须先乘后除</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint n,k,q,d;\nll a[N],b[N];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;\n        for(int i=1;i&lt;=k;++i)\n        &#123;\n            cin &gt;&gt; a[i];\n        &#125;\n        for(int i=1;i&lt;=k;++i)\n        &#123;\n            cin &gt;&gt; b[i];\n        &#125;\n        while(q--)\n        &#123;\n            cin &gt;&gt; d;\n            if(d==0)\n            &#123;\n                cout &lt;&lt; 0 &lt;&lt; &quot; &quot;;\n                continue;\n            &#125;\n            ll i = lower_bound(a,a+k+1,d)-a;\n            ll b_left=b[i-1],b_right=b[i];\n            cout &lt;&lt; b_left + (b_right-b_left) * (d-a[i-1]) / (a[i]-a[i-1])  &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codeforces.com/contest/1971\">Codeforces Round 944 (Div. 4)</a></p>\n<p><a href=\"https://codeforces.com/contest/1971/problem/E\">E. Find the Car</a></p>\n<p>计算时必须先乘后除</p>\n<pre><code class=\"cpp\">// By SnowDream\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nint n,k,q,d;\nll a[N],b[N];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin &gt;&gt; t;\n    while(t--)\n    &#123;\n        cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;\n        for(int i=1;i&lt;=k;++i)\n        &#123;\n            cin &gt;&gt; a[i];\n        &#125;\n        for(int i=1;i&lt;=k;++i)\n        &#123;\n            cin &gt;&gt; b[i];\n        &#125;\n        while(q--)\n        &#123;\n            cin &gt;&gt; d;\n            if(d==0)\n            &#123;\n                cout &lt;&lt; 0 &lt;&lt; &quot; &quot;;\n                continue;\n            &#125;\n            ll i = lower_bound(a,a+k+1,d)-a;\n            ll b_left=b[i-1],b_right=b[i];\n            cout &lt;&lt; b_left + (b_right-b_left) * (d-a[i-1]) / (a[i]-a[i-1])  &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; &quot;\\n&quot;;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm2mlm0xr000blgw17ndl7hx8","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0xu000ilgw1h82x3rlj"},{"post_id":"cm2mlm0xo0005lgw18rmg3oj8","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0xu000klgw1f6zz1ko9"},{"post_id":"cm2mlm0xs000dlgw1dm46cy56","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0xu000mlgw17mqtgl6k"},{"post_id":"cm2mlm0xt000glgw14cd7erqc","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0xv000plgw1e7nnf324"},{"post_id":"cm2mlm0xq0008lgw1gnqf2esd","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0xv000rlgw1g9a8fylw"},{"post_id":"cm2mlm0xt000hlgw1a3tvb9r5","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0xv000tlgw17vq3ebko"},{"post_id":"cm2mlm0xy0012lgw1e8ev5zvp","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y00018lgw15hp562lu"},{"post_id":"cm2mlm0xy0013lgw1a1byeptx","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y0001algw1842ac65y"},{"post_id":"cm2mlm0xz0015lgw1cb6tbpeg","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y0001elgw1e6vkb3ew"},{"post_id":"cm2mlm0xz0017lgw10qdj7g52","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y1001hlgw15ywy9bj8"},{"post_id":"cm2mlm0y00019lgw1b11pbs8m","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y2001llgw1cs5z03mp"},{"post_id":"cm2mlm0y0001clgw1dhxscni7","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y2001olgw1crq15w5g"},{"post_id":"cm2mlm0y1001glgw1aowoa45r","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y3001rlgw1csss90bc"},{"post_id":"cm2mlm0y1001jlgw1ctwn7izq","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y3001vlgw14awk2b9i"},{"post_id":"cm2mlm0y2001nlgw1fvcg67ax","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y4001xlgw15p1ha42k"},{"post_id":"cm2mlm0y2001qlgw1b57199gi","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y4001zlgw10v2o2tm5"},{"post_id":"cm2mlm0y3001ulgw1ectt5rtg","category_id":"cm2mlm0xp0007lgw16u0l4qpa","_id":"cm2mlm0y40021lgw13gbagacu"}],"PostTag":[{"post_id":"cm2mlm0xp0006lgw10c5vabng","tag_id":"cm2mlm0xn0004lgw11qlufvt6","_id":"cm2mlm0xr000algw1fctd19eu"},{"post_id":"cm2mlm0xk0001lgw1htq7fze8","tag_id":"cm2mlm0xn0004lgw11qlufvt6","_id":"cm2mlm0xs000clgw1cp5fdfrb"},{"post_id":"cm2mlm0xm0003lgw111kh9v9p","tag_id":"cm2mlm0xn0004lgw11qlufvt6","_id":"cm2mlm0xu000llgw18uy8gup9"},{"post_id":"cm2mlm0xm0003lgw111kh9v9p","tag_id":"cm2mlm0xs000flgw1ey17e68n","_id":"cm2mlm0xu000nlgw1e9c9foqo"},{"post_id":"cm2mlm0xo0005lgw18rmg3oj8","tag_id":"cm2mlm0xu000jlgw15asz2gat","_id":"cm2mlm0xv000qlgw14qsfec7l"},{"post_id":"cm2mlm0xq0008lgw1gnqf2esd","tag_id":"cm2mlm0xu000olgw1apvv2d3h","_id":"cm2mlm0xv000ulgw18msyhdyq"},{"post_id":"cm2mlm0xr000blgw17ndl7hx8","tag_id":"cm2mlm0xu000olgw1apvv2d3h","_id":"cm2mlm0xv000wlgw13hy05utf"},{"post_id":"cm2mlm0xs000dlgw1dm46cy56","tag_id":"cm2mlm0xv000vlgw11pj60fps","_id":"cm2mlm0xv000ylgw154x747q8"},{"post_id":"cm2mlm0xt000glgw14cd7erqc","tag_id":"cm2mlm0xu000jlgw15asz2gat","_id":"cm2mlm0xw0010lgw160gj6m0l"},{"post_id":"cm2mlm0xt000hlgw1a3tvb9r5","tag_id":"cm2mlm0xv000vlgw11pj60fps","_id":"cm2mlm0xw0011lgw11sl176qi"},{"post_id":"cm2mlm0xy0012lgw1e8ev5zvp","tag_id":"cm2mlm0xv000vlgw11pj60fps","_id":"cm2mlm0xz0014lgw190kzelas"},{"post_id":"cm2mlm0xz0017lgw10qdj7g52","tag_id":"cm2mlm0xv000vlgw11pj60fps","_id":"cm2mlm0y0001blgw1hmoz9hze"},{"post_id":"cm2mlm0xy0013lgw1a1byeptx","tag_id":"cm2mlm0xz0016lgw1dqsi51jn","_id":"cm2mlm0y1001flgw1b1e5d98a"},{"post_id":"cm2mlm0y0001clgw1dhxscni7","tag_id":"cm2mlm0xz0016lgw1dqsi51jn","_id":"cm2mlm0y1001ilgw10epb7lq2"},{"post_id":"cm2mlm0y1001glgw1aowoa45r","tag_id":"cm2mlm0xu000jlgw15asz2gat","_id":"cm2mlm0y2001mlgw1h18i1cvb"},{"post_id":"cm2mlm0xz0015lgw1cb6tbpeg","tag_id":"cm2mlm0xz0016lgw1dqsi51jn","_id":"cm2mlm0y2001plgw1h4ug8fpu"},{"post_id":"cm2mlm0y2001nlgw1fvcg67ax","tag_id":"cm2mlm0y2001klgw12p5r1xsy","_id":"cm2mlm0y3001tlgw1b4spa3ug"},{"post_id":"cm2mlm0y00019lgw1b11pbs8m","tag_id":"cm2mlm0y2001klgw12p5r1xsy","_id":"cm2mlm0y3001wlgw1d7gkdzr1"},{"post_id":"cm2mlm0y2001qlgw1b57199gi","tag_id":"cm2mlm0y2001klgw12p5r1xsy","_id":"cm2mlm0y4001ylgw17hp411km"},{"post_id":"cm2mlm0y3001ulgw1ectt5rtg","tag_id":"cm2mlm0y2001klgw12p5r1xsy","_id":"cm2mlm0y40020lgw10cyo1ori"},{"post_id":"cm2mlm0y1001jlgw1ctwn7izq","tag_id":"cm2mlm0y2001klgw12p5r1xsy","_id":"cm2mlm0y40022lgw1b9az6siu"}],"Tag":[{"name":"算法","_id":"cm2mlm0xn0004lgw11qlufvt6"},{"name":"上机作业","_id":"cm2mlm0xs000flgw1ey17e68n"},{"name":"Codeforces Round 934 (Div. 2)","_id":"cm2mlm0xu000jlgw15asz2gat"},{"name":"Codeforces Round 936 (Div. 2)","_id":"cm2mlm0xu000olgw1apvv2d3h"},{"name":"Codeforces Round 937 (Div. 4)","_id":"cm2mlm0xv000vlgw11pj60fps"},{"name":"Codeforces Round 946 (Div. 3)","_id":"cm2mlm0xz0016lgw1dqsi51jn"},{"name":"Codeforces Round 944 (Div. 4)","_id":"cm2mlm0y2001klgw12p5r1xsy"}]}}